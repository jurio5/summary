- JPA에서 엔티티를 1차 캐시(영속성 컨텍스트)에 보관하여 관리하는 개념
- 이를 통해 변경 감지(더티 체킹), 지연 로딩(LAZY), 프록시 객체 같은 기능을 사용가능

```java
@Entity
class Member {

@Id @GeneratedValue
private Long id;

private String name;

@ManyToOne(fetch = FetchType.LAZY) // LAZY 설정
private Team team; // 팀과 연관 관계
}
```

### 엔티티의 생명주기

- 비영속 (`new` / `transient`)
- 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- ex) `Member member = new Member`
- 영속 (`managed`)
- 영속성 컨텍스트에 관리되는 상태
- 정확히는 영속성 컨텍스트 1차 캐시에 올라와 있으면 JPA가 자동으로 관리해주는 상태를 영속 상태라고 함
- ex) `entityManager.persist(member)`
- ex) `entityManager.find(member)`
- 준영속 (detached)
- 영속성 컨텍스트에 저장되었다가 분리된 상태
- ex) Item 엔티티에서 `PK`가 담긴 데이터 하나를 `update`할 때 Item 의 `PK`가 필요한데, 이 `update`할 때 필요한 `PK`는 이미 영속 된 상태의 `PK`였다가 `update`를 하기 위해 가져오면 준영속 상태가 된다. 즉, 영속성 컨텍스트에 저장되었다가 다시 호출 된 상태
- 이를 다시 저장하기 위해선 추천하진 않지만 `merge`를 이용하거나, 레포지터리에서 `PK`값을 찾으면 영속 된 상태의 `PK`값이 불러와지는데 그 영속 된 상태인 `PK`를 이용하여 데이터를 수정 시 트랜잭션 내부에서 `commit`이 발생하면서 저장되면서 영속 된 상태로 새로 저장된다.
- 준영속 상태로 만드는 방법
- `em.detach(entity)` : 특정 엔티티만 준영속 상태로 전환
- `em.clear()` : 영속성 컨텍스트를 완전히 초기화
- `em.close()` : 영속성 컨텍스트를 종료
- 삭제 (removed)
- 삭제된 상태

### 영속성 컨텍스트의 이점

- 1차 캐시
- 트랜잭션 내부에서 `PK`저장 후 `find` 시 1차 캐시에서 조회
- 1차 캐시에 없는 `PK`일 시 `DB`에서 조회 후 있다면 불러와서 1차 캐시에 다시 저장 후 조회

- 동일성(`identity`) 보장
- 트랜잭션 내부에서는 정확히는 트랜잭션 내부에서 동일성(`==`)을 보장
- 기본적으로 자바에선 동일한 인스턴스 참조 객체가 아니라면 `false`를 반환하지만, 트랜잭션 내부에선 동일성을 보장
- 1차 캐시로 반복 가능한 읽기(`REPEATABLE READ`)등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공

- 트랜잭션을 지원하는 쓰기 지연 (`transactional write-behind`)
- 데이터를 영속화(`persist`)할 때 영속성 컨텍스트(`1차 캐시`)에 저장 후 `쓰기 지연 SQL 저장소`에 `INSERT SQL`을 생성하여 저장
- 저장되는 시점은 `entityManager.commit(member)` 시 `flush`를 통해 `INSERT SQL`을 `DB`에 저장하고, 실제 `commit`시 `DB`에 저장된다.
- 쓰기 지연 SQL 에선 버퍼링 기능을 하는데, 영속화 된 데이터들을 모아두고 있다가 한 번에 `flush`후 `commit`을 하여 저장이 되기에 기본적으로 네트워크 자원을 아껴서 성능의 이점을 끌어올릴 수 있다. (`batch_size` 설정을 통하여 한 번에 보낼 개수를 지정 가능 (이 부분은 `N + 1`의 문제를 어느정도 해소해줄 수 있음))