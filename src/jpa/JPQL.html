
### JPQL 소개

- JPQL은 객체지향 쿼리 언어이다. 따라서 테이블을 대상으로 쿼리 하는 것이 아니라 엔티티 객체를 대상으로 쿼리를 한다.
- JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다
- JPQL은 결국 SQL로 변환된다.

### JPQL 문법

- `select m from Member as m where m.age > 18`
- 엔티티와 속성은 대소문자 구분을 한다. (Member, age)
- JPQL 키워드는 대소문자 구분하지 않는다 (SELECT, FROM where)
- 테이블의 이름이 아닌 엔티티 이름을 사용 (Member)
- 별칭은 필수(`m`), `as`는 생략 가능

### 집합과 정렬

```java
select
COUNT(m), // 회원 수
SUM(m.age) // 나이 합
AVG(m.age) // 평균 나이
MAX(m.age) // 최대 나이
MIN(m.age) // 최소 나이
from Member m
```
- GROUP BY, HAVING
- ORDER BY

### TypeQuery, Query

- TypeQuery : 반환 타입이 명확할 때 사용
- Query : 반환 타입이 명확하지 않을 때 사용

```java
TypeQuery<Member> query = em.createQuery("select m from Member m", Member.class); // 타입이 명확 -> TypeQuery

    Query query = em.createQuery("select m.name, m.age from Member m") // 타입 불명확 -> Query

    ```


    ### 결과 조회 API

    - `query.getResultList()` : 결과가 하나 이상일 때, 리스트 반환
    - 결과가 없으면 빈 리스트 반환 (`NPE` 걱정 X, 빈 컬렉션을 반환)
    - query.getSingleResult() : 결과가 정확히 하나, 단일 객체 반환
    - 결과가 없으면 : `NoResultException`
    - 둘 이상이면 : `NonUniqueResultException`
    - 결론은 정확히 데이터가 하나일 때 사용

    ### 파라미터 바인딩 - 이름 기반, 위치 기반

    ```java
    // 이름 기반 바인딩
    select m from Member m where m.name = :name

    query.setParameter("name", usernameParam);

    // 위치 기반 바인딩 -> 사용 X
    select m from Member m where m.name = ?1
    query.setParameter(1, usernameParam);
    ```

    ### 프로젝션

    - SELECT 절에 조회 할 대상을 지정하는 것
    - 프로젝션 대상 : 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자 등 기본 데이터 타입)

    ```java
    select m from Member m -> 엔티티 프로젝션
    select m.team from Member m -> 엔티티 프로젝션
    select m.address from Member m, Address.class -> 임베디드 타입 프로젝션
    select m.username, m.age from Member m -> 스칼라 타입 프로젝션

    ---

    // 이 엔티티 프로젝션은 예측을 하기가 힘듦 (Join SQL이 실행된다.)
    select m.team from Member m, Member.class

    // 아래와 같은 방식으로 직접적으로 조인을 해주는게 관리하기가 훨씬 수월
    select t from Member m join m.team t, Team.class
    ```
    - `DISTINCT` 로 중복 제거 가능

    ### 프로젝션 - 여러 값 조회

    - 프로젝션 조회의 경우 패치조인이 **불가능**
    - `select m.username, m.age from Member m`
    1. Query 타입으로 조회
    2. Object[] 타입으로 조회
    ```java
    List<Object[]> resultList = em.createQuery("select m.username, m.age from Member m, Member.class).getResultList();

    Object[] result = result.get(0);
    System.out.Println("username = " + result[0]);
    System.out.Println("age = " + result[1]);
    ```
    3. new 명령어로 조회 (베스트 프랙티스)
    단순 값을 DTO로 바로 조회
    ```java
    List<MemberDTO> result = em.createQuery("select new jpabook.jpashop.jpql.MemberDTO(m.name, m.age) from Member m", MemberDTO.class)
        .getResultList();
        ```
        패키지 명을 포함한 전체 클래스 명 입력
        순서와 타입이 일치하는 생성자 필요


        ### 페이징 API

        - JPA는 페이징을 다음 두 API 로 추상화
        - `setFirstResult(int startPosition)` : 조회 시작 위치 (`0 부터 시작`)
        - `setMaxResults(int maxResult)` : 조회 할 데이터 수

        ### 조인

        - 내부 조인 : [] 부분은 생략 가능
        - `select m from Member m [inner] join m.team.t`
        - 외부 조인 : [] 부분은 생략 가능
        - `select m from Member m left [outer] join m.team t`
        - 세타 조인 :
        - `select count(m) from Member m, Team t where m.username = t.name`

        ### 조인 - ON 절

        - ON절을 활용한 조인 (`JPA 2.1 ↑`)
        1. 조인 대상 필터링
        2. 연관관계가 없는 엔티티 외부 조인 (`Hibernate 5.1 ↑`)

        ### 조인 - 조인 대상 필터링

        - 예시로 회원과 팀을 조인하면서, 팀 이름이 A인 팀만 조인

        ```java
        // JPQL
        select m, t from Member m LEFT JOIN m.team t on t.name = 'A'

        // SQL
        select m.*, t.* from Member m LEFT JOIN Team t ON m.TEAM_ID=t.id and t.name ='A'
        ```

        ### 조인 - 연관관계가 없는 엔티티 외부 조인

        - 예시로 회원의 이름과 팀의 이름이 같은 대상 외부 조인

        ```java
        // JPQL
        select m, t from Member m LEFT JOIN Team t on m.username = t.name

        // SQL
        select m.*, t.* from Member m LEFT JOIN Team t ON m.username = t.name
        ```

        ### 서브 쿼리

        - 나이가 평균보다 많은 회원
        - `select m from Member m where m.age > (select avg(m2.age) from Member m2)`
        - 한 건이라도 주문한 고객
        - `select m from Member m where (select count(o) from Order o where m = o.member > 0)`

        ### 서브 쿼리 지원 함수

        - [NOT] EXISTS (subquery) : 서브 쿼리에 결과가 존재하면 참
        - {`ALL | ANY | SOME`} (subquery)
        - `ALL` : 모두 만족하면 참
        - `ANY`,`SOME` : 같은 의미, 조건을 하나라도 만족하면 참
        - [NOT] IN (subquery) : 서브쿼리의 결과 중 하나라도 같은 것이 있으면 참

        ### 서브 쿼리 - 예제

        - 팀A 소속인 회원
        - `select m from Member m where exists (select t from m.team t where t.name = '팀A')`
        - 전체 상품 가각의 재고보다 주문량이 많은 주문들
        - `select o from Order o where o.orderAmount > ALL (select p.stockAmount from Product p)`
        - 어떤 팀이든 팀에 소속된 회원
        - `select m from Member m where m.team = ANY (select t from Team t)`

        ### JPA 서브 쿼리 한계

        - JPA는 WHERE, HAVING 절에서만 서브 쿼리 사용 가능
        - SELECT 절도 가능 (하이버네이트에서 지원)
        - FROM 절의 서브 쿼리는 현재 JPQL에서 불가능
        - 조인으로 풀 수 있으면 풀어서 해결
        - 혹은 쿼리를 2번 날려서 해결, 2번 날려도 해결 불가능 시 네이티브 쿼리 사용

        ### JPQL 타입 표현

        - 문자 : `'HELLO'`, `'She's''`
        - 숫자 : `10L(Long)`, `10D(Double)`, `10F(float)`
        - Boolean : `TRUE`, `FALSE`
        - `ENUM` : `jpabook.MemberType.Admin` (패키지 명 포함)
        - 엔티티 타입 : TYPE(m) = Member (상속 관계에서 사용)

        ### JPQL 기타

        - SQL과 문법이 흡사함
        - `EXISTS`,`IN`
        - `AND, OR, NOT`
        - `= , > , >=, < , <=, <>`
        - `BETWEEN, LIKE, IS NULL, IS NOT NULL`
        ### 조건식 - CASE 식

        - 기본 CASE 식

        ```java
        select
        case when m.age <= 10 then '학생요금'
        when m.age >= 60 then '경로요금'
        else '일반요금'
        end
        from Member m
        ```

        - 단순 CASE 식

        ```java
        select
        case t.name
        when '팀A' then '인센티브110%'
        when '팀B' then '인센티브120%'
        else '인센티브105%'
        end
        from Team t
        ```

        - `COALESCE` : 하나 씩 조회해서  `null`이 아니면 반환
        - `NULLIF` : 두 값이 같으면 `null` 반환, 다르면 첫 번째 값 반환
        - 사용자 이름이 없으면 이름 없는 회원을 반환
        - `select coalesce(m.username, '이름 없는 회원') from Member m`

        ### JPQL 기본 함수

        - `CONCAT`
        - `SUBSTRING`
        - `TRIM`
        - `LOWER, UPPER`
        - `LENGTH`
        - `LOCATE`
        - `ABS, SQRT, MOD`
        - `SIZE, INDEX(JPA 용도)`

        ### 사용자 정의 함수 호출

        - 기본 함수로 해결할 수 없을 때 사용
        - 하이버네이트는 사용 전 방언에 추가해야 한다.
        - 사용하는 DB 방언을 상속받고, 사용자 정의 함수를 등록한다.
        - `select function('group_concat', i.name) from Item i`

        ### 경로 표현식

        - .(점, (참조))을 찍어 객체 그래프를 탐색하는 것

        ```java
        select m.username -> 상태 필드
        from Member m
        join m.team t -> 단일 값 연관 필드
        join m.orders o -> 컬렉션 값 연관 필드
        where t.name - '팀A'

        ```

        ### 경로 표현식 용어 정리

        - 상태 필드(`state field`) : 단순히 값을 저장하기 위한 필드
        - `m.username
        - 연관 필드(`association field) : 연관관계를 위한 필드
        - 단일 값 연관 필드
        - `@ManyToOne, OneToOne, 타겟 대상이 엔티티 일 때`
        - ex) `m.team`
        - 컬렉션 값 연관 필드
        - `@OneToMany, @ManyToMany, 타겟 대상이 컬렉션 일 때`
        - ex) `m.orders`

        ### 경로 표현식 특징

        - 상태 필드 : 경로 탐색의 끝, 더 이상 탐색 불가능
        - `select m.username 여기서 m.username.(점 부분) 참조 불가능`
        - 단일 값 연관 경로 : **묵시적 내부 조인 발생,** 탐색 가능
        - `select m.team.name 이 같이 참조를 통해 계속 객체 그래프 탐색 가능`
        - 컬렉션 값 연관 경로 : **묵시적 내부 조인 발생**, 탐색 불가능
        - `select t.members.(점 부분) 참조 불가능`
        - FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능
        - `select m.username from Team t join t.members m`
        - 결론은 위 같은 묵시적 조인을 사용하지 말라 (명시적 조인을 사용하는게 보편적)

        ### 명시적 조인, 묵시적 조인

        - 명시적 조인 : `join` 키워드를 직접 사용
        - `select m from Member m join m.team t`
        - 묵시적 조인 : 경로 표현식에 의해 묵시적으로 SQL 조인 발생 (내부 조인만 가능, 외부 조인 불가능(`Left Outer Join`))
        - `select m.team from Member m`

        ### 경로 탐색을 사용한 묵시적 조인 시 주의사항

        - 항상 내부 조인
        - 컬렉션은 경로 탐색의 끝이므로, 명시적 조인을 통해 별칭을 얻어야 함
        - `select m.username from Team t join t.members m`
        - 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만, 묵시적 조인으로 인해 SQL의 FROM (JOIN) 절에 영향을 줌

        ### 실무 조언

        - 가급적 묵시적 조언 대신 명시적 조인 사용
        - 조인은 SQL 튜닝에 중요 포인트이기 때문
        - 묵시적 조인은 조인이 일어나는 상황을 한 눈에 파악하기가 어려움

        ### 패치 조인 (`fetch join`) - 매우 중요

        - SQL의 조인 종류가 아님
        - JPQL 에서 성능 최적화를 위해 제공하는 기능
        - 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능
        - `join fetch` 명령어를 통해 사용
        - 패치 조인 = [ LEFT || INNER ] JOIN FETCH 조인 경로 방식으로 사용 가능

        ### 엔티티 패치 조인

        - 회원을 조회하면서 연관된 팀도 함께 조회 (SQL을 한 번에)
        - SQL을 보면 회원 뿐만 아니라 팀(`T.*`) 도 함께 SELECT
        - JPQL
        - `select m from Member m join fetch m.team`
        - SQL
        - `select m.*, T.* from Member m inner join Team T ON M.TEAM_ID=T.ID`
        - 지연 로딩이 설정 된 엔티티를 조회해도 `fetch join`을 하면 프록시 객체를 가져오는게 아닌 실제 객체로 가져온다. (물론 실제 객체이기에 프록시 객체를 초기화하여 값을 가져오지 않아도, 이미 그 객체 내부에 값이 들어있는 상태)

        ### 컬렉션 패치 조인

        - 일대다 관계, 컬렉션 패치 조인
        - JPQL
        - `select t from Team t join fetch t.members where t.name = '팀A'`
        - SQL
        - `select T.*, M.* from Team T inner join Member M ON T.ID = M.Team_Id where T.NAME = '팀A'`

        ### 패치 조인과 DISTINTCT

        - SQL의 DISTINCT는 중복된 결과를 제거하는 명령어이다.
        - JPQL의 DISTINCT는 2가지 기능을 제공한다.
        1.  SQL에 DISTINCT를 추가
        2. 애플리케이션에서 엔티티 중복 제거
        - `select distinct t from Team t join fetch t.members where t.name = '팀A'`
        - SQL에 DISTINCT를 추가하지만 데이터가 다르므로 SQL 결과에서 중복 제거 실패

        ![[SQL DISTINCT.png]]
        - DISTINCT가 붙으면 JPA에서 추가로 애플리케이션에서 중복 제거 시도
        - 같은 식별자를 가진 `TEAM`엔티티 제거
        - 결론은 애플리케이션 레벨에서 JPA가 DISTINCT를 사용 할 때 최적화 함
        - 이러한 문제는 일대다 연관관계의 SQL 레벨에서의 문제이고, 객체에선 문제 없다는 뜻
        - 물론 다대일 관계에선 조인을 사용해도 이러한 문제는 발생하지 않음

        ### 패치 조인과 일반 조인의 차이

        - 일반 조인 실행 시 연관된 엔티티를 함께 조회하지 않음
        ```java
        // JPQL
        select t from Team t join t.members where t.name = '팀A'

        // SQL
        select t.* from team t inner join Member m ON t.id=m.team_id where t.name = '팀A'
        ```
        - JPQL은 연관관계를 알지만, 명시적으로 조회하지 않으면 연관된 엔티티는 가져오지 않음
        - 일반 조인 일 때
        - SQL은 애초에 객체 그래프 개념이 업성서 연관관계를 고려하지 않음
        - 단지 select 절에 지정한 엔티티만 조회할 뿐
        - 여기서는 팀 엔티티만 조회하고, 회원 엔티티는 조회하지 않음
        - 택배 배송에 비유
        - 일반 조인
        - 상자만 오고 내용물은 나중에 따로 받음 (1차 쿼리 후, 연관된 데이터는 필요할 때 추가로 요청) -> N + 1 문제 발생 가능 -> 성능 저하
        - 패치 조인
        - 상자 안에 내용물까지 다 들어있음 (한 번의 쿼리로 모든 데이터를 한 번에 조회) -> 성능 향상
        - 패치 조인을 사용할 때만 연관된 엔티티도 함께 조회 (즉시 로딩)
        - 패치 조인은 객체 그래프를 SQL 한 번에 조회하는 개념

        ### 패치 조인의 특징과 한계

        - 패치 조인 대상에는 별칭을 줄 수 없다.
        - 하이버네이트는 가능, 그러나 가급적 사용하지 말기
        - 둘 이상의 컬렉션은 패치 조인 할 수 없다.
        - 컬렉션을 패치 조인하면 페이징 API(`setFirstResult`, `setMaxResults`)를 사용할 수 없다.
        - 일대일, 다대일 같은 단일 값 연관 필드들은 패치 조인을 해도 페이징 가능
        - 하이버네이트는 경고 로그를 남기고 메모리에서 페이징 (매우 위험함)
        - `select t from Team t join fetch t.members (컬렉션 패치 조인)`
        - `setFirstResult ~` -> 매우 위험
        - 일대다,다대일 양방향 연관관계 이기에 다대일 방식으로 `fetch join`해서 해결
        - 일대다를 사용할 때 컬렉션의 문제를 해결하는 방법
        - `Batch Size`설정을 통해 쿼리 성능 개선 가능

        - 연관된 엔티티들을 SQL 한 번으로 조회 - 성능 최적화
        - 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함
        - `@OneToMany(fetch = FetchType.LAZY)` // 글로벌 로딩 전략
        - 실무에서 글로벌 로딩 전략은 모두 지연 로딩
        - 최적화가 필요한 곳은 패치 조인을 적용
        - `N + 1` 문제 등

        ### 패치 조인 정리

        - 모든 것을 패치 조인으로 해결하진 못 함
        - 패치 조인은 객체 그래프를 유지할 때 사용하면 효과적
        - 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 패치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적

        ### 다형성 쿼리

        - Type
        - 조회 대상을 특정 자식으로 한정
        - 예로 들어 Item 중에 Book, Movie 를 조회할 때
        ```java
        // JPQL
        select i from Item i where type(i) IN (Book, Movie)

        // SQL
        select i from i where i.DTYPE in ('B', 'M')
        ```
        - TREAT (`JPA2.1`)
        - 자바의 타입 캐스팅과 유사
        - 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용
        - FROM, WHERE SELECT(하이버네이트 지원) 사용
        - 예로 들어 부모인 Item과 자식 Book 이 있을 때
        ```java
        // JPQL
        select i from Item i where treat(i as Book).auther = 'kim'

        // SQL (쿼리 구현 전략에 따라 다름, (싱글,조인 등))
        select i.* from Item i wheere i.DTYPE = 'B' and i.auther = 'kim'
        ```


        ### 엔티티 직접 사용 - 기본 키 값

        - JPQL 에서 엔티티를 직접 사용하면 SQL 에서 해당 엔티티의 기본 키 값을 사용
        ```java
        // JPQL
        select count(m.id) from Member m // 엔티티의 아이디를 사용
        select count(m) from Member m // 엔티티를 직접 사용 (SQL에선 m.id로 바꿔서 사용)

        // SQL (JPQL 둘 다 아래와 같은 SQL이 실행)
        select count(m.id) as cnt from Member m
        ```
        - 엔티티를 조건으로 걸어서 바인딩해도 SQL 에선 식별자로 변환하여 사용 (`m = :member -> m.id = ?`)
        ```java
        // 엔티티를 파라미터로 전달
        String jpql = "select m from Member m where m = :member";
        List resultList = em.createQuery(jpql)
        .setParameter("member", member)
        .getSingleResult();

        // 식별자를 직접 전달
        String jpql = "select m from Member m where m.id = :memberId";
        List resultList = em.createQuery(jpql)
        .setParameter("memberId", member.getId())
        .getSingleResult();

        // 실행된 SQL
        select m.*(물론 SQL에선 * 가 출력되는게 아닌 속성 값들이 나열되어 출력) from Member m where m.id = ?
        ```

        ### 엔티티 직접 사용 - 외래 키 값

        ```java
        // JPQL
        Team team = em.find(Team.class, 1L);

        String qlString = "select m from Member m where m.team = :team";
        List resultList = em.createQuery(qlString)
        .setParameter("team", team)
        .getResultList();

        String qlString = "select m from Member m where m.team.id = :teamId";
        List resultList = em.createQuery(qlString)
        .setParameter("teamId", team.getId())
        .getResultList();

        // 실행된 SQL
        select m.* from Member m where m.team_id=?
        ```

        ### Named 쿼리 - 정적 쿼리

        - 미리 정의해서 이름을 부여해두고 사용하는 JPQL
        - 정적 쿼리에서만 사용 가능
        - 어노테이션, XML에 정의
        - 애플리케이션 로딩 시점에 초기화 후 재사용
        - 애플리케이션 로딩 시점에 쿼리를 검증
        - Spring Data JPA 에서의 `@Query` 어노테이션도 Named 쿼리를 사용

        ### Named 쿼리 - 어노테이션

        ```java
        @Entity
        @NamedQuery(
        name = "Member.findByUsername", // 관례 상 엔티티 명.XXX 로 사용
        query = "select m from Member m where m.name = :name"
        )
        public class Member {
        ...
        }

        List<Member> resultList = em.createNamedQuery("Member.findByUsername", Member.class)
            .setParameter("name", "회원1")
            .getResultList();
            ```

            ### Named 쿼리 환경에 따른 정의

            - XML이 항상 우선권을 가진다.
            - 애플리케이션 운영 환경에 따라 다른 XML을 배포할 수 있다.

            ### 벌크 연산

            - 재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면?
            - JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL 실행
            1. 재고가 10개 미만인 상품을 리스트로 조회한다.
            2. 상품 엔티티의 가격을 10% 증가한다.
            3. 트랜잭션 커밋 시점에 변경 감지가 동작한다.
            - 변경된 데이터가 100건 이라면 100번의 `update sql`이 실행된다.
            - Spring Data JPA 에서의 `@Modifying` + `Query` 어노테이션이 벌크 연산을 사용

            ### 벌크 연산의 예제

            - 쿼리 한 번으로 여러 테이블 (엔티티) 로우 변경
            - `executeUpdate()`의 결과는 영향받은 엔티티 수 반환
            - `update`,`delete`지원
            - `insery(insert into ... select, 하이버네이트 지원)`
            ```java
            String qlString = "update Product p set p.price = p.price * 1.1 where p.stockAmout < :stockAmount";

            int resultCount = em.createQuery(qlString)
            .setParameters("stockAmount", 10)
            .executeUpdate();
            ```

            ### 벌크 연산 주의점

            - 벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리함
            - 해결 방법
            1. 벌크 연산을 먼저 실행
            2. 벌크 연산 수행 후 영속성 컨텍스트 초기화
            ```java
            Member member1 = new Member();
            member1.setTeam(teamA);
            em.persist(member1);

            Member member2 = new Member();
            member2.setTeam(teamB);
            em.persist(member2);

            em.flush();
            em.clear();

            String sql = "update Member m set m.age = 20";
            // 이 때 flush() 호출 (DB 에는 age 컬럼이 20으로 변경되어 있음)
            int resultCount = em.createQuery(sql, Member.class)
            .executeUpdate();

            System.out.println("member1.getAge() = " + member1.getAge()); // 호출 시 age 는 0으로 출력
            // 이유는 쓰기 SQL 에서 DB 로 쿼리만 날렸을 뿐 영속성 컨텍스트 내부에 있는 age 값은 그대로임

            em.clear(); // 영속성 컨텍스트 초기화 후

            Member findMember = em.find(Member.class, member1.getId());
            System.out.println("findMember.getAge() = " + findMember.getAge()); // 다시 DB 에서 영속성 컨텍스트로 데이터를 가져온 뒤 조회 -> 20 정상 호출
            ```