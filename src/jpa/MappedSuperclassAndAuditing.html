
- 공통 매핑 정보가 필요할 때 사용 (`id`, `name`, `LocalDateTime` 등)
- 엔티티 생성, 변경할 때 변경한 사람과 시간을 추적하고 싶을 때
- 등록일
- 수정일
- 등록자
- 수정자
### MappedSuperclass

- 상속관계 매핑이 아님
- 물리 모델링 전략(`조인`,`단일` 등)같이 직접 DB에 테이블을 만드는게 아닌, 코드 레벨에서 공통적인 필드만 추가해주는 역할
- 엔티티가 아니고 테이블과 매핑이 안 된다.
- 부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공
- 조회, 검색 불가(`em.find(BaseEntity.class, ~))
- 직접 생성해서 사용할 일이 없으므로, 추상 클래스 권장
- 테이블과 관계없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할
- 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용
- `@Entity` 클래스는 엔티티나 `@MappedSuperclass`로 지정한 클래스만 상속 가능
- 이 말 뜻은 `@Entity` 어노테이션이 붙은 엔티티는 기본적으로 상속받을 수 없고, 상속하려면 상대가 엔티티 객체이거나, MappedSuperclass로 지정 된 클래스만 상속받을 수 있다.


### JPA

```java
@MappedSuperclass
@Getter
public class JpaBaseEntity {

@Column(updatable = false)
private LocalDateTime createdDate;

private LocalDateTime updatedDate;

@PrePersist
public void prePersist() {
LocalDateTime now = LocalDateTime.now();
createdDate = now;
updatedDate = now;
}

@PreUpdate
public void preUpdate() {
updatedDate = LocalDateTime.now();
}

...

void test() {
Member member = new Member("member1");
memberRepository.save(member); // @PrePersist 발생

Thread.sleep(100);
member.setUsername("member2");

em.flush(); // @PreUpdate 발생
em.clear();
}
```

- JPA 주요 이벤트 어노테이션
- `@PrePersist`, `@PostPersist`
- `@PreUpdate`, `PostUpdate`


### Spring Data JPA

- Application 객체에 `@EnableJpaAuditing`가 들어가있어야 정상적으로 작동

```java
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
@Getter
public class BaseTimeEntity {

@CreatedDate
@Column(updatable = false)
private LocalDateTime createdDate;

@LastModifiedDate
private LocalDateTime LastModifiedDate;
}
...

@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
@Getter
public class BaseEntity extends BaseTimeEntity {

@CreatedBy
@Column(updatable = false)
private String createdBy;

@LastModifiedBy
private String lastModifiedBy;
}
```

- `createdBy`,`lastModifiedBy` 필드는 등록자 수정자를 나타내는데, 여기에 어떤 방식으로 등록자와 수정자의 데이터가 들어가냐, 라는 부분에서는 한 가지 설정이 더 필요하다.

```java
public class Application {

public static void main(String[] args) {
SpringApplication.run(DataJpaApplication.class, args);
}

@Bean
public AuditorAware<String> auditorProvider() {
  return () -> Optional.of(UUID.randomUUID().toString());
  // 실제 사용 시 UUID 부분을 스프링 시큐리티에서 사용자 세션 정보를 가져와서 넣어줘야 함
  }
  ```

  - Application 에 위 와 같은 `AuditorAware`를 스프링 빈으로 등록하면, `BaseEntity`를 상속받고 있는 엔티티들의 변경이 감지될 때 자동으로 `AuditorAware`가 필드를 채워넣어주는 방식으로 동작한다.

  ### 결론

  - Auditing 을 사용할 땐 `@EnableJpaAuditing` 어노테이션을 애플리케이션에 추가해줘야한다.
  - `@CreatedBy`,`@LastModifiedBy`를 사용할 때 역시 `AuditorAware`를 애플리케이션에 스프링 빈으로 등록해줘야 한다.
  - 기본적으로 모든 엔티티에서 생성일,수정일의 공통 필드들은 대부분 다 사용하지만, 생성자,수정자의 정보를 사용하지 않는 엔티티가 존재할 수 있음으로 `MappedSuperclass`간의 상속을 통해 선택지를 추가하여 해결한다.
  - 생성일, 수정일 만 필요한 경우 `BaseTimeEntity`를 엔티티에 상속
  - 생성일, 수정일, 생성자, 수정자 전부 필요한 경우 `BaseEntity`를 엔티티에 상속