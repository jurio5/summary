
### 프록시 기초

- `entityManager.find()`와 `entityManager.getReference()`
- `entityManager.find()` : 데이터베이스를 통해서 실제 엔티티 객체를 조회
- `entityManager.getReference()` : 데이터베이스 조회를 미루는 가짜(프록시)엔티티 객체 조회

![[프록시.png]]

### 프록시 특징

- 실제 클래스를 상속 받아서 만들어짐
- 실제 클래스와 겉 모양이 같음
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다. (**이론상**)
- 프록시 객체는 실제 객체의 참조(`target`)를 보관 (초기에는 `null`)
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메서드를 호출

![[프록시 객체의 초기화.png]]
- 프록시 객체는 처음 사용할 때 한 번만 초기화
- 초기화 요청 이라는 말은 영속성 컨텍스트에게 이에 대한 데이터가 없으니 DB에서 객체를 만들어서 연결시켜 줘 라는 느낌으로 이해
- 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아니고, 초기화가 되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
- 실제 엔티티에 접근을 한다는 것이지, 프록시 객체에서 실제 객체로 변경되어 데이터가 매핑 되는게 아니라, 프록시 객체에서 실제 엔티티 객체에 접근해서 `target`참조를 한 뒤 처음 한 번 초기화 후 다음 호출 부터는 프록시 객체에서 호출한다는 뜻
- 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크 시 주의해야 함(`동일성(==)` 비교는 실패하므로, `instance of`를 대신 사용해야 함)
- `Member`타입 일 경우 `member1` == `member2` 방식은 상대 객체가 프록시라서 `false`를 출력
- `(member1 instanceof Member)`,`(member2 instanceof Member)`같은 방식으로 사용 시 `true`를 출력
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 `entityManager.getReference()`를 호출해도 실제 엔티티 반환, 이 부분을 예제로 들면
```java
EntityManager em;

Member member = new Member();
member.setName("user1");
em.persist(member);

// 이미 존재하는 Member 타입의 `PK`를 수정 시 DB에 UPDATE
em.flush(); // 지금은 DB에 없는 신규 엔티티로 이 때 쓰기 지연 SQL에서 값을 DB에 INSERT
em.clear(); // 영속성 컨텍스트를 비움 (1차 캐시 제거)

// DB에서 다시 조회하여 새로운 영속 상태의 엔티티 생성
Member findMember = em.find(Member.class, member.getId());

// getReference()는 보통 프록시를 반환하지만,
// 이미 영속성 컨텍스트에 해당 엔티티가 존재하면 실제 엔티티를 반환
Member reference = em.getReference(Member.class, member.getId());

// 결론
// 이 동일성(==)에 대한 결과는 `true`를 반환
// 이유는 한 트랜잭션 내부(영속성 컨텍스트)에선 `PK`와 `타입(Member)`이 같다면
// 동일성을 보장해주기 때문!
log.info("m1 == m2 : " + (findMember == reference));
```
- 만약 영속성 컨텍스트를 비운 뒤(`clear`) `em.find`가 아닌 `em.getReference`를 통해 영속성 컨텍스트에 엔티티를 올렸다면, 두 번째 불러오는 `em.getReference` 역시 똑같은 프록시 객체가 생성이 된다. (`r1 == r2 -> true`)
- 그렇다면 반대의 입장의 예시를 보면
```java
EntityManager em;

Member member = new Member();
member.setName("user1");
em.persist(member);

// 이미 존재하는 Member 타입의 `PK`를 수정 시 DB에 UPDATE
em.flush(); // 지금은 DB에 없는 신규 엔티티로 이 때 쓰기 지연 SQL에서 값을 DB에 INSERT
em.clear(); // 영속성 컨텍스트를 비움 (1차 캐시 제거)

// DB에서 다시 조회하여 새로운 영속 상태의 프록시 엔티티 생성
Member reference = em.getReference(Member.class, member.getId());

// JPA는 항상 동일성을 보장해줘야하기에 `find`로 찾아도 이미 생성 된 프록시 객체를 사용
Member findMember = em.find(Member.class, member.getId());

// 결론적으론 JPA는 이 동일성 역시 프록시 객체를 그대로 사용하여 `true`를 반환!
log.info("m1 == m2 : " + (findMember == reference));
```

- **영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생**
- 이를 아래의 예시로 들어보면
```java
EntityManager em;

Member member = new Member();
member.setName("Test");
em.persist(member);

// 프록시 객체 생성
Member refMember = em.getReference(Member.class, member.getId());

// 아래와 같이 영속성 컨텍스트에서 분리하는 작업을 수행하면:
em.detach(refMember); // 프록시 객체를 준영속 상태로 만들거나
em.clear();           // 영속성 컨텍스트(1차 캐시)를 모두 비우거나
em.close();           // 영속성 컨텍스트 자체를 종료하면

// 이제 프록시 객체(refMember)는 DB에서 실제 데이터를 로딩할 수 없음
refMember.getName();
// 호출 시 LazyInitializationException 발생:
// → "could not initialize proxy - no Session"
// 물론 이 부분은 예외를 찍어야 볼 수 있음

// 이유:
// getReference()로 생성된 프록시는 실제 DB 접근을 지연(Lazy)시킴.
// 따라서 프록시에서 실제 데이터를 처음 조회할 때(초기화 시점에)
// 영속성 컨텍스트(EntityManager)가 유효하지 않으면 DB에 접근할 수 없고,
// 그 결과로 예외가 발생함.

// 결론은 가급적이면 `getReference()`는 영속성 컨텍스트 내에서만 사용하는게 안전
```

### 프록시 확인

- 프록시 인스턴스의 초기화 여부 확인
- 초기화 여부는 `Lazy`방식으로 작동하기에 `getName()`과 같은 프로퍼티 접근법으로 호출 시 그때 프록시 객체에서 영속성 컨텍스트로 초기화를 요청 함
- `PersistenceUnitUtil.isLoaded(Object entity)` -> 다만 이 경우는 `EntityManagerFactory`를 주입하여 사용해야하는데, 스프링에선 이걸 자동으로 관리하기에 차선책을 사용할 수 있음
- `Hibernate`를 사용한다면 더 유연한 방법인 `Hibernate.isInitialized(proxy)`를 사용
-  이 방식은 프록시 객체든 컬렉션이든 모두 체크 가능
- `EntityManagerFactory`없이도 사용할 수 있음
- 단점은 하이버네이트 종속적이라는 것 (JPA 표준 아님)

- 프록시 클래스 확인 방법
- `entity.getClass().getName()`

- 프록시 강제 초기화
- 위 예제처럼 `refMember.getName()`으로 강제로 초기화를 할 수 있지만, `Hibernate.isInitialized(entity)`를 통해 강제 초기화 가능
- 다만 위 방식의 강제 초기화는 하이버네이트 기준이고, JPA 표준은 강제 초기화가 없음
- 고로, JPA 에서 강제 초기화를 할 땐 프로퍼티 접근 방식으로 초기화를 해야 함

### 지연 로딩 LAZY을 사용해서 프록시로 조회

```java
class Member {
@ManyToOne(fetch = FetchType.LAZY) // 지연 로딩 사용 시 프록시 객체를 생성
private Team team;
}
Member member = new Member();

em.find(Member.class, member.getId());

Team team = member.getTeam();
team.getName(); // 실제 team을 사용하는 시점에 초기화
```

### 프록시와 즉시 로딩 주의

- 가급적 지연 로딩만 사용 (특히 실무에선 더욱)
- 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생
- 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.
- `JPQL`을 이용하여 `select m from Member m` 과 같은 형식으로 작성을 할 때 기본적으로 `JPQL`에서 선언한 SQL 1번이 실행되고, 내부에 `Team`을 연관관계로 `EAGER`설정이 되어있으면 그 `N`개 만큼 쿼리가 더 나간다고 하여 `N + 1`문제 라고 한다.
- 물론, 이 부분을 해결하는 1차적인 방법은 지연 로딩으로 변경하는 것인데 지연 로딩으로 설정을 한다고 해도 결국 반복문을 돌리면서 프록시 객체를 생성
- 프록시 객체를 계속 생성하는 이유는 `PK`마다 `Team` 내부, 예로 들면 `name`이 다르기 때문에 JPA는 동일성을 유지하기 위하여 계속 프록시 객체를 생성하기 때문
- 해결 방법은 크게 3가지가 있다.
- **Fetch Join 사용 (`JOIN FETCH`)**
- `select m from Member m join fetch m.team`
- **Batch Size 설정 (`@BatchSize(size=10)`)**
- **EntityGraph 활용**

- `@ManyToOne`, `@OneToOne`은 기본이 즉시 로딩 -> 지연 로딩으로 설정해줘야 함
- `@OneToMany`, `@ManyToMany`는 기본이 지연 로딩

### 글로벌 Fetch 전략 설정 결론

- 모든 연관관계를 지연 로딩(Lazy Loading)으로 설정
- `@ManyToOne`, `@OneToOne`은 기본이 즉시 로딩이므로 지연 로딩으로 변경

