- `FetchType.LAZY` 사용 시, 여러 개의 엔티티를 조회할 때 연관된 엔티티를 추가로 조회하면서 발생하는 문제

```java
List<Member> members = em.createQuery("SELECT m FROM Member m", Member.class).getResultList(); // 1번의 쿼리 실행

  for (Member member : members) { System.out.println(member.getTeam().getName()); // N번 추가 쿼리 실행 }
  ```

  - `Member` 조회 시 `SELECT * FROM member` (1번 실행)
  - `getTeam().getName()` 호출 시 `SELECT * FROM team WHERE id=?` (N번 실행)

  💡 **해결법**
  1. **Fetch Join 사용**
  2. **EntityGraph 적용**
  3. **Batch Size 설정 (`@BatchSize(size = 10)`)**

  ```java
  // Fetch Join 사용
  List<Member> members = em.createQuery( "SELECT m FROM Member m JOIN FETCH m.team", Member.class ).getResultList(); // 단 1번의 쿼리만 실행됨!
    ```


    ### 정리

    - N + 1 문제의 경우 즉시 로딩 관계에서도 발생할 수 있지만, 주로 지연 로딩 관계에서 자주 발생하는 성능 이슈 입니다.
    - 예로 들어 다대일 일대다 양방향 연관관계에서 Many 쪽의 엔티티를 조회할 때 연관된 One 쪽의 엔티티를 반복 호출하는 경우 발생합니다.
    - N + 1  문제를 해결하기 위해선 `Fetch Join` , `Entity Graph`, `Batch Size`를 통해 문제를 해결할 수 있습니다.
    - `Fetch Join`의 경우 연관된 엔티티들을 하나의 `JPQL`의 쿼리에서 조인하여 한 번에 조회함으로써 N + 1 문제를 해결하는 대표적인 방법입니다.
    - `Batch Size`는 하이버네이트 설정으로, 지연 로딩 시 한 번에 몇 개씩 연관 엔티티를 조회할지 지정해 쿼리 호출 횟수를 줄이는 기법입니다. 이로 인하여 성능면으로 이점을 얻을 수도 있습니다.
    - `Entity Graph`는 JPA에서 제공하는 기능으로, 조회 시점에 필요한 연관 엔티티를 명시하여 쿼리를 최적화 할 수 있습니다.