
### 다대일 관계 조회 최적화

- 엔티티를 반환하지 않기
- DTO로 변환하여 반환
- N + 1 문제가 발생하는 지점이 보여도, 초기에는 글로벌 패치 레벨을 `LAZY`로 설정 후 추후에 성능 상 병목 문제가 생기거나 할 때 패치 조인 혹은 배치 사이즈, 엔티티 그래프 등을 통하여 문제를 해결
- 패치 조인을 할 때 엔티티를 반환? DTO를 반환?
- 이 부분에는 트레이드 오프가 있는데, 엔티티를 반환할 땐 이 메서드를 재사용할 수 있고, JPA에서 관리를 하는데 단점은 조회 시 연관관계에 있는 모든 필드까지 한 번에 전부 다 조회가 되는 문제가 발생, 즉 네트워크 비용을 조금 더 많이 사용한다는 뜻
- DTO로 반환할 땐 프로젝션 조회를 통해 명확한 데이터를 명시하여 반환하지만, 종속적임. 즉, 리포지터리의 재사용이 거의 불가능하고 프로젝션 조회 특성 상 DTO를 조회할 때 복잡해져서 유지보수성이 떨어짐. 장점의 경우는 딱 원하는 데이터들만 불러올 수 있기에 리소스 비용이 적게 들어감
```java
public List<OrderSimpleQueryDto> findOrderDto() {
  return em.createQuery("select new jpabook.jpashop.domain.repository.OrderSimpleQueryDto(o.id, m.name, o.orderDate, o.status, d.address) from Order o" +
  " join o.member m" +
  " join o.delivery d", OrderSimpleQueryDto.class)
  .getResultList();
  ```
  - DTO를 리포지터리에서 반환할 때 한 가지 더 큰 문제점은 API의 스펙이 달라지면 이 코드 자체를 뜯어내야 한다는 부분 이러한 문제 때문에 오히려 유지보수성에 대한 문제가 생길 수 있음
  - 결론은 엔티티를 반환할 때 문제점은 성능에 대한 문제점인데 요즘 시대의 환경에서 이러한 미비한 차이가 내 프로젝트에서 큰 차이를 낼 수 있는지 생각을 해보면서 성능에 대한 비교를 해보고 결정해야 함 (관리자 API 정도는 괜찮은데, 트래픽이 많은 API에 조회하는 필드가 십수개가 되는 경우 등), 웬만하면 엔티티 방식을 선호
  - 쿼리 방식 선택 권장 순서
  1. 우선 엔티티를 DTO로 변환하는 방법을 선택
  2. 필요하면 패치 조인으로 성능을 최적화 -> 대부분의 성능 이슈 해결
  3. 그래도 안되면 DTO로 직접 조회하는 방법을 사용하여 성능 이슈 해결
  4. 최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해서 SQL을 직접 사용

  ### 일대다 관계 컬렉션 조회 최적화

  - DTO 내부에 엔티티가 포함되어선 안 된다. (랩핑 역시 X)
  - 외부에 노출이 되기 때문에 DTO 내부에서 엔티티를 호출 시 그 엔티티 역시 DTO로 변환하여 사용
  - 임베디드 벨류 오브젝트 같은 경우는 괜찮음
  - 패치 조인 시 일대다 관계에선 다 쪽의 로우 수 만큼 데이터가 조회된다.
  - 스프링 부트 3.x 버전, 정확히는 Hibernate 6.1 버전을 사용 시 자동으로 패치 조인 시 `distinct`를 적용시켜줘서 요즘에는 명시하지 않아도 괜찮지만 의도를 위해 명시해주는 걸 추천
  - 그러나 이 부분은 Java 레벨에서 중복을 제거하는 것일 뿐 SQL 레벨에서는 아직 중복되는 데이터들이 전송되기에 네트워크 비용 및 메모리 사용량 같은 성능 문제는 여전히 발생한다.
  - SQL 레벨에서는 `distinct`의 경우 그 로우의 줄이 전부 다 같아야 중복이라고 판단하고 제거하기 때문
  - 일대다 관계에서 패치 조인을 했을 시 가장 큰 문제는 페이징이 불가능하다는 것
  - 정확히는 페이징 처리는 할 수 있지만, 하이버네이트에서 데이터들을 전부 다 가져와서 리스트에 담아둔 뒤(메모리에 담아둠) List를 슬라이스(`subList`같은 메서드) 하는데, 데이터의 수가 수 만 건 이상이라면 몇 번 조회하면 아웃 오브 메모리가 발생하는 문제가 생김
  - 이로 인하여 일대다 관계에선 페이징을 하지 않는게 베스트 프랙티스
  - 컬렉션 패치 조인은 1개만 사용할 수 있음, 컬렉션 둘 이상에 패치 조인을 사용하면 데이터가 부정합하게 조회될 수 있기에 사용하면 안 된다. (`1:N`도 복잡한데 `1:N:M`이 되면 JPA가 평탄화를 시키면서 데이터 정합성에 문제가 생긴다는 뜻)
  - 그렇다면 컬렉션 조회를 하면서 페이징을 해야할 때 어떻게 해결할 수 있는가?
  - 일단 `OneToOne, ManyToOne`관계의 경우는 패치 조인을 하여도 로우의 수가 증가하지 않기 때문에 몇 개를 패치 조인을 하고 페이징을 해도 괜찮다.
  ```java
  entityManager.createQuery("select o from Order o join fetch o.member m join fetch o.delivery join fetch m.oauth oa join fetch ...") // OneToOne, ManyToOne 관계에선 몇 개를 패치 조인하든 문제가 없음
  ```
  - `@OneToOne`, `@ManyToOne`과 같은 단일 연관 관계는 **패치 조인(fetch join)** 으로 한 방 쿼리로 가져오도록 최적화할 수 있다.
  - 반면, `@OneToMany`, `@ManyToMany`처럼 **컬렉션 형태의 연관관계는 지연 로딩(Lazy Loading)** 을 유지하는 것이 일반적이다.
  - 지연 로딩으로 인해 발생할 수 있는 **N+1 문제**를 방지하고자, `@BatchSize` 어노테이션이나 하이버네이트의 **글로벌 배치 설정**을 사용하면 컬렉션이나 프록시 객체를 **한 번에 지정한 크기만큼 `IN` 쿼리로 조회**하게 되어 성능을 향상시킬 수 있다.
  - `BatchSize`를 활용해 1:N뿐만 아니라 1:1 관계도 **IN 쿼리로 한 번에 가져올 수 있게 최적화**할 수 있다.
  - 그러나 이렇게 되면 한 번에 **많은 양의 데이터를 애플리케이션으로 가져오게 되므로 메모리 사용량이 증가**할 수 있다.
  - 대신 **네트워크 왕복 비용은 줄어들어 전체적인 성능은 개선**되는 경우가 많다.
  - 다만 패치 조인으로 일대다 컬렉션을 조회할 땐 페이징이 불가능하지만, 위 와 같은 방식처럼 컬렉션 조회는 전부 지연 로딩으로 둔 채 `BatchSize`를 통해서 해결을 하면, 컬렉션 조회에도 페이징을 사용할 수 있다는 장점이 있다.
  - `BatchSize`의 경우 미니점의 경우는 몇 개를 해도 괜찮지만, 맥시멈 사이즈는 `1000`개 정도로 잡아야한다.
  - - 일부 **DB 벤더에서는 `IN` 절의 파라미터 개수를 1000개로 제한**하는 경우가 있다.
  - `BatchSize`만큼의 데이터를 한 번에 애플리케이션으로 전달하기 때문에, 너무 큰 값은 **애플리케이션 메모리 사용량을 급격히 증가**시킬 수 있다.
  - 물론, 로직의 대부분은 전부 다 반복문을 끝까지 돌리기 때문에 100개로 제한을 하든, 1000개로 제한을 하든 메모리 사용량은 같다고 볼 수 있다.
  - 다대일 관계는 N+1 문제가 발생하지 않아 크게 문제가 되지 않지만, 일대다 관계는 N+1 문제가 발생할 수 있기에 주의가 필요하다. 복잡한 일대다 컬렉션 구조는 다대일 형태로 플랫하게 조회한 후, Java에서 다시 계층 구조로 조립함으로써 조회 쿼리를 1회로 줄일 수 있다. 즉, 한방 쿼리 + 메모리 재조립 방식으로 N+1 문제를 해결할 수 있다.
  - 정리하자면, 다대일 같은 경우는 N + 1 문제가 발생하지 않아 괜찮지만, 일대다 같은 경우는 다대일로 플랫화 후 자바로 다시 조립하여 한방 쿼리를 통해 조회 1번으로 복잡한 구조의 컬렉션 조회 문제를 해결할 수 있다.

  ### 권장 접근 순서

  1. 엔티티 조회 방식으로 우선 접근
  1. 패치 조인으로 쿼리 수를 최적화
  2. 컬렉션 최적화
  1. 페이징 필요 -> `BatchSize`로 최적화 (`BatchSize`는 보통 글로벌 설정)
  2. 페이징 필요 없음 -> 패치 조인 사용
  2. 엔티티 조회 방식으로 해결 안 되면 DTO 조회 방식 사용
  3. DTO 조회 방식으로 해결이 안 된다면 네이티브SQL 또는 스프링 JdbcTemplate 으로 해결

  - 참고로 엔티티 조회 방식은 패치 조인이나, `BatchSize` 같이 코드를 거의 수정하지 않고, 옵션만 약간 병경해서, 다양한 성능 최적화를 시도할 수 있다. 반면에 DTO를 직접 조회하는 방식은 성능을 최적화 하거나 성능 최적화 방식을 변경할 때 많은 코드를 변경해야한다.
  - 트래픽이 엄청 많지 않은 이상 DTO 조회를 하기 보다는 캐시 즉, 레디스 같은 것을 사용하여 성능을 향상 시키는 것을 목표로 설정
  - 캐싱을 할 때 주의점은 엔티티는 직접 캐싱을 하면 안 된다. JPA가 영속성 컨텍스트로 관리하고 있는데 캐시를 하고 있으면 지워지지 않는 문제가 생길 수 있기에 DTO로 변환하여 DTO를 캐시해야 함

  ### 선택과 집중

  - 개발자는 성능 최적화와 코드 복잡도 사이에서 줄타기를 해야 한다. 항상 그런 것은 아니지만, 보통 성능 최적화는 단순한 코드를 복잡한 코드로 몰고간다.
  - 엔티티 조회 방식은 JPA가 많은 부분을 최적화 해주기 때문에(`BatchSize` 등) , 단순한 코드를 유지하면서, 성능을 최적화 할 수 있다.
  - 반면에 DTO 조회 방식은 SQL을 직접 다루는 것과 유사하기 때문에, 성능 최적화와 코드 복잡도 사이에서 줄타기를 잘 해야한다.

  - DTO로 조회하는 방법도 각각 장단이 있다. 단순하게 쿼리가 1번 실행된다고 항상 좋은 방법인 것은 아니다. (대부분 엔티티 조회 + 패치 조인 + `Batch Size` 등으로 해결된다.)