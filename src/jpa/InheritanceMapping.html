
### 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법

- 조인 전략 (각각 테이블로 변환, **가장 추천**)
- `Item` 테이블과 하위 테이블을 DB에서 상속하는 방식 중 첫 번째로는 조인 전략이 있다.
- `Item`테이블에 `Type`을 구분하는 컬럼을 만들어둔 뒤 공통적인 속성들은 `Item`테이블 컬럼을 만들고, 분류되는 속성들은 하위 테이블에 넣어서 조인을 하여 두 번의 `insert`를 통해 저장하는 방식

- 단일 테이블 전략 (통합 테이블로 변환, **확장 가능성이 없고 단순할 때 추천**)
- 논리적인 모델을 하나의 테이블로 합치는 전략
- 컬럼을 `Item`테이블에 다 넣은 뒤 `Type`을 통해 구분하는 방식

- 서브타입 테이블로 변환 (구현 클래스마다 테이블 전략, **비추천**)
- `Type`들을 그냥 각각 테이블로 다 만들어서 구현하는 전략
- `Item`테이블을 만들지 않고, `ALBUM`,`MOVIE`,`BOOK`처럼 카테고리 테이블들을 직접 만들어서 구현하는 전략

### 각 전략에 따른 장단점

- 조인 전략
- 장점
- 테이블 정규화
- 외래 키 참조 무결성 제약조건 활용 가능
- 저장 공간 효율화
- 단점
- 조회 시 조인을 많이 사용, 성능 저하
- 조회 쿼리가 복잡함
- 데이터 저장 시 `insert sql`2번 호출
- 단일 테이블 전략
- 장점
- 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
- 조회 쿼리가 단순함
- 단점
- 자식 엔티티가 매핑한 컬럼은 모두 null 허용
- 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있고, 상황에 따라서 조회 성능이 오히려 느려질 수 있다.
- 구현 클래스마다 테이블 전략
- 이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천하지 않음
- 장점
- 서브 타입을 명확하게 구분해서 처리할 때 효과적
- NOT NULL 제약조건 사용 가능
- 단점
- 여러 자식 테이블을 함께 조회할 때 성능이 느림 (`union sql`)
- 자식 테이블을 통합해서 쿼리하기 어려움