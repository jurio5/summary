
### CGLIB (Code Generator Library)

- `CGLIB`는 바이트 코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리 이다.
- `CGLIB`를 사용하면 인터페이스가 없어도 구체 클래스만 가지고 동적 프록시를 만들어낼 수 있다.
- 참고로, `CGLIB`를 직접 사용하는 경우는 거의 없고, 스프링의 `ProxyFactory`라는 것을 사용함으로 `CGLIB`가 무엇인지 대략적인 개념만 잡고 넘어가면 된다.

- JDK 동적 프록시에서 실행 로직을 위해 `InvocationHandler`를 제공했듯이, `CGLIB`는 `MethodInterceptor`를 제공한다.

```java
public interface MethodInterceptor extend Callback {
Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable;
}
```

- `obj` : CGLIB가 적용된 객체
- `method` : 호출된 메서드
- `args` : 메서드를 호출하면서 전달 된 인수
- `proxy` : 메서드 호출에 사용

```java
@RequiredArgsConstructor
@Slf4j
public class TimeMethodInterceptor implements MethodInterceptor {

private final Object target;

@Override
public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
log.info("TimeProxy 실행");
long startTime = System.currentTimeMillis();

Object result = methodProxy.invoke(target, args);

long endTime = System.currentTimeMillis();

log.info("TimeProxy 종료, resultTime={}", (endTime - startTime));
return result;
}
}
```

- `Method method`를 사용해도 괜찮지만, `CGLIB`는 `MethodProxy methodProxy`를 사용하는 걸 더 권장한다.
- 내부적으로 최적화를 하여 조금 더 빠르게 사용할 수 있다.

```java
@Test
void cglib() {
ConcreteService target = new ConcreteService();

Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(ConcreteService.class);
enhancer.setCallback(new TimeMethodInterceptor(target));
ConcreteService proxy = (ConcreteService) enhancer.create(); // 동적 프록시 생성
log.info("targetClass={}", target.getClass());
log.info("proxyClass={}", proxy.getClass());

proxy.call();
}
```

### CGLIB 제약

- 클래스 기반 프록시는 상속을 사용하기 때문에 몇 가지 제약이 있다.
- 부모 클래스의 생성자를 체크해야 한다. -> CGLIB는 자식 클래스를 동적으로 생성하기 때문에 기본 생성자가 필요하다.
- 클래스에 `final` 키워드가 붙으면 상속이 불가능하다. -> CGLIB 에서는 예외가 발생한다.
- 메서드에 `final` 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다. -> CGLIB에서는 프록시 로직이 동작하지 않는다.
- 여기서 문제점은 JDK 동적 프록시의 경우 인터페이스가 있어야 사이 가능하고, 구체 클래스에 프록시를 적용하기 위해선 CGLIB 기술이 필요하다. 그럼 여기서 인터페이스라면 JDK 동적 프록시를 사용하고, 구체 클래스라면 CGLIB를 사용하도록 자동으로 매핑 해주는 방식이 있다면 좋을텐데, 이를 해결할 수 있도록 스프링에서 지원하는 [[ProxyFactory]] 가 존재한다.