
### 들어가기에 앞서

- 좋은 설계는 `변하는 것과 변하지 않는 것`을 분리하는 것이다.
- 여기서 핵심 기능 부분은 변하고, 부가 기능은 변하지 않는 부분이다.
- 이 둘을 분리해서 모듈화해야 한다면, `템플릿 메서드 패턴(Template Method Pattern)`을 사용하면 된다.

```java
public void orderItem(String itemId) {
TraceStatus status = null;
try {
status = trace.begin("OrderService.request()");
orderRepository.save(itemId); // 핵심 기능
trace.end(status);
} catch (Exception e) {
trace.exception(status, e);
throw e; // 그 외 부가 기능
}
}
```
- 핵심 기능은 한 줄이지만, 그걸 위해 동반되는 부가 기능들이 훨씬 많은 상황

### 템플릿 메서드 패턴

![[템플릿 메서드 패턴 구조.png]]

- 템플릿 메서드 패턴은 이름 그대로 템플릿을 사용하는 방식이다. 템플릿은 기준이 되는 거태한 틀이다. 템플릿 이라는 틀에 변하지 않는 부분을 몰아둔다. 그리고 일부 변하는 부분을 별도로 호출하여 해결한다.
```java
@Slf4j
public abstract class AbstractTemplate {

public void execute() {
long startTime = System.currentTimeMillis();
// 비즈니스 로직 실행
call();
// 비즈니스 로직 종료
long endTime = System.currentTimeMillis();
log.info("resultTime={}", (endTime - startTime));
}

protected abstract void call();
}
```

- `AbstractTemplate` 코드를 보면 변하지 않는 부분인 시간 측정 로직인 부가 기능들을 몰아둔 것을 확인할 수 있다. 이제 이것이 하나의 템플릿이 된다. 그리고 템플릿 안에서 변하는 부분은 `call()`메서드를 호출해서 처리한다. 템플릿 메서드 패턴은 부모 클래스에 변하지 않는 템플릿 코드를 둔다. 그리고 변하는 부분은 자식 클래스에 두고 상속과 오버라이딩을 사용해서 처리한다.

![[템플릿 메서드 패턴 호출.png]]

```java
@Slf4j
public class SubClassLogic1 extends  AbstractTemplate {

@Override
protected void call() {
log.info("비즈니스 로직1 실행");
}
}

...

/**
* 템플릿 메서드 패턴 적용
*/
@Test
void templateMethodV1() {
AbstractTemplate template1 = new SubClassLogic1();
template1.execute();

AbstractTemplate template2 = new SubClassLogic2();
template2.execute();
}
```

- 템플릿 메서드 패턴을 적용하면 핵심 기능과 부가 기능을 분리하게 되면서 `SRP`를 지키는 설계 방식의 구조가 완성된다.
- 단점은 `SubClassLogic1`,`SubClassLogic2`처럼 클래스를 계속 만들어야 한다는 단점이 있는데 이는 익명 내부 클래스를 통해 보완할 수 있다.

```java
@Test
void templateMethodV2() {
AbstractTemplate template1 = new AbstractTemplate() {
@Override
protected void call() {
log.info("비즈니스 로직1 실행");
}
};

AbstractTemplate template2 = new AbstractTemplate() {
@Override
protected void call() {
log.info("비즈니스 로직2 실행");
}
};

template1.execute();
template2.execute();
}
```

### 템플릿 메서드 실제 적용

```java
@RequiredArgsConstructor
public abstract class AbstractTemplate<T> {

  private final LogTrace trace;

  public T execute(String message) {
  TraceStatus status = null;
  try {
  status = trace.begin(message);

  // 로직 호출
  T result = call();
  // 로직 호출 종료

  trace.end(status);
  return result;
  } catch (Exception e) {
  trace.exception(status, e);
  throw e;
  }
  }

  protected abstract T call();
  }

  ...

  public void orderItem(String itemId) {
  AbstractTemplate<Void> template = new AbstractTemplate<>(trace) {
    @Override
    protected Void call() {
    orderRepository.save(itemId);
    return null;
    }
    };
    template.execute("OrderService.orderItem()");
    }
    ```
    - 참고로 제네릭에서 반환 타입이 필요한데, 반환 할 내용이 없으면 `Void`타입을 사용하고 `null`을 반환하면 된다. 제네릭은 기본 타입인 `void`,`int`등을 선언할 수 없다.

    ### 결론

    - 템플릿 메서드 패턴은 좋은 방식의 설계라고 볼 수 있는지에 대해서 생각을 해봐야한다.
    - 일단 첫 번째 문제는 핵심 기능과 부가 기능을 분리하였지만 여전히 비즈니스 로직에 익명 내부 클래스를 정의하여 사용을 해야한다던가 클래스를 하나 만들어서 사용을 해야한다던지 이러한 불편한 부분과 순수 비즈니스 로직에만 집중하지 못하는 구조라는 부분에서 한 번 더 생각을 해봐야한다.
    - 더 중요한 부분은 `상속`을 사용한다는건데 잘 생각해보면 템플릿 메서드 패턴은 부모 클래스를 상속받고 오버 라이딩하여 사용을 한다. 여기서 문제는 자식 클래스는 부모 클래스를 `상속`받지만 상속받은 기능들을 사용하진 않는다는 것도 문제이고, 어쨋든 자식이 부모를 바라보는 연관관계에서 결합도가 높아진다는 문제가 생긴다. 결합도가 높아지면 부모 팩토리에서 또 다른 추상 메서드가 생겼을 때 그 부모 팩토리를 상속받는 자식들은 그 추상 메서드까지 전부 다 구현을 해줘야한다는 부분도 유지보수를 할 때 좋은 설계인지, 객체지향 구조를 설계할 때 독립적인 모듈을 높이기 위해선 응집도를 높히고 결합도는 낮춰야한다는 점에서 조금 더 생각을 해봐야한다.
    - 템플릿 메서드는 이 와 같이 상속 구조를 사용하기에 위 와 같은 문제들이 발생하는데, 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴이 바로 `전략 패턴(Stretegy Pattern)`이다. -> [[전략 패턴]]