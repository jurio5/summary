
### 베스트 프랙티스

```java
public Response exam(@PathVariable Long id, Request request) {
memberService.update(id, request.getName()) // 반환 값 void
Member findMember = memberService.find(id);
return new Response(findMember.getId(), findMember.getName());
}
```

- 위 코드는 프레젠테이션 계층에서 `CQS`패턴을 사용하여 구현 한 코드이다.
- 여기서 `CQS`패턴의 문제는 2번의 쿼리가 나가고 개발 편의성이 낮아진다는 부분인데, 과연 이러한 것들을 포기 할 만큼 얻는 이점이 클까?
- `CQS`패턴으로 얻을 수 있는 이점은 `Query` 와 `Command`를 분리하여 유지 보수성과 테스트 용이성 정도를 얻을 수 있다.
- 바로 결론으로 들어가면, 작은 프로젝트에선 기존 방식대로 DTO를 비즈니스 로직 단에서 반환하는게 편의성 측면으로는 더 좋지만, 추후 조금 더 미래를 보면서 개발을 한다면 `CQS`패턴을 통해 개발을 하는게 더 좋다고 생각된다.
- 사실 그렇게 크게 손이 더 많이 가는 것도 아니고, 2번의 조회 정도야 현대 시대에선 엄청난 트래픽이 들어오는게 아닌 이상 티끌도 되지 않는 수준이고, 중요한 부분은 나중에 리팩토링을 할 여지를 하나라도 더 줄인다는 관점에서 보면, 베스트 프랙티스 까지는 아니겠지만 충분히 좋은 설계라고 느껴진다.
- 총 정리를 하면, `Command` 의 경우 시스템의 상태를 변경하는 쓰기(`insert, update, delete`) 같은 작업을 할 때를 말하고, 반환 타입은 원칙적으로는 `void`타입을 받지만, 꼭 필요한 경우는 `boolean`,`id`,`Result`,`Status` 같은 간단한 값만 반환해야 함. 즉, 비즈니스 로직 실행을 위한 목적이며, 컨트롤러에서는 성공 여부나 간단한 결과만 받음
- `Query`의 경우는 시스템의 상태를 조회하는 읽기 작업(`select`) 을 할 때를 말하고, 반환 값은 필수로 데이터를 반환해줘야 한다. 이는 읽기 전용이며, 절대 상태 변경 로직이 포함되면 안 된다는 것을 주의하자.
