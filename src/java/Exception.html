
![[예외 계층.jpg]]

- `Error` : 메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션에서 복구 불가능한 시스템 예외
- 애플리케이션 개발자는 이 예외를 잡으려고 해서는 안 된다.
- 상위 예외를 `catch`로 잡으면 그 하위 예외까지 함께 잡는다. 따라서 애플리케이션 로직에서는 `Throwable`예외도 잡으면 안되는데, 그 이유는 `Error`예외도 함께 잡을 수 있기 때문
- 애플리케이션 로직은 이런 이유로 `Exception`부터 필요한 예외로 생각하고 잡으면 된다.
- `Error`도 언체크 예외

### 예외 기본 규칙
- 예외에 대해서는 2가지 기본 규칙이 있다.
1. 예외는 잡아서 처리하거나 던진다.
2. 예외를 잡거나 던질 때 지정한 예외뿐만 아니라 그 예외의 자식들도 함께 처리된다.
- 예를 들어서 `Exception`을 `catch`로 잡으면 그 하위 예외들도 모두 잡을 수 있다.
- 예를 들어서 `Exception`을 `throws`로 던지면 그 하위 예외들도 모두 던질 수 있다.
- 기본적으로 언체크(런타임) 예외를 사용하자
- 체크 예외는 비즈니스 로직에서 의도적으로 던지는 예외에만 사용하자.
- 이 경우 해당 예외를 잡아서 반드시 처리해야 하는 문제일 때만 체크 예외를 사용해야 한다.
- 예를 들어서 다음과 같은 경우가 있다
- 계좌 이체 실패 예외
- 결제 시 포인트 부족 예외
- 로그인 ID, PW 불일치 예외
- 물론 이 경우에도 100% 체크 예외로 만들어야 하는 것은 아니다. 다만, 계좌 이체 실패처럼 매우 심각한 문제는 개발자가 실수로 예외를 놓치면 안 된다고 판단할 수 있다. 이 경우 체크 예외로 만들어두면 컴파일러를 통해 놓친 예외를 인지할 수 있다.
- 체크 예외를 선언했을 때 만약 `Repository`에서 선언을 했으면 `Service`,`Controller` 전부 다 그 체크 예외를 상속 받아야하고 `Service`에서 잡았다고 치더라도, 추후에 구현체를 갈아끼웠을 때 발생하는 체크 예외들을 전부 다 바꿔줘야 하는 문제가 생기면서 `DI`즉, OOP 방식에 위배되는 행위가 생긴다.
- `Exception`으로 체크 예외를 한 번에 다 잡으면 되지않냐? 라고 할 수도 있지만, 이 경우는 체크 예외를 사용하는 목적성을 잃어버리게 된다. 체크 예외의 경우 계죄 이체 실패처럼 중요한 문제를 다룰때만 사용을 하는데, `Exception`으로 처리를 해버리는 순간 모든 예외를 다 던져버리기 때문에 체크 예외의 이점을 잃게된다는 뜻이다.
- 더 근본적인 문제는 예외 같은 경우는 사실 직접 로직에서 처리를 할 수 있는 로직이 많지 않기 때문에 언체크 예외로 사용하는 이유이기도 하고, 이 때문에 메시지를 잘 남기고 문서화를 잘 해두는게 중요
- 이러한 문제들 때문에 체크 예외 보다는 현대의 스프링에서는 런타임 예외를 주로 사용한다.
- 런타임 예외의 경우도 체크 예외처럼 `try`,`catch`로 잡아서 처리할 수 있으니 선택적으로 처리가 가능하지만, 컴파일 단에서 잡아주지 않기에 개발자가 놓칠 수 있기 때문에 문서화가 중요하다.
- 예외를 전환할 땐 꼭 기존 예외의 정보를 담아줘야 한다.
- 루트 예외부터 전부 `Cause`에 담아주는게 중요하다.
```java
// 여기선 RuntimeException 을 상속하는 Class
public void RootException(Throwable cause) { // RootException.class 라고 가정
super(cause);
}

public void Exception1() throws SQLException {
throw new SQLException; // Checked Exception 발생
}

public void Exception2() {
try {
Exception1(); // 여기서 체크 예외로 인하여 예외를 던지지 않고 잡아줌
} catch (SQLException e) {
throw new RootException(e); // RuntimeException 으로 잡아줌
}
}
```