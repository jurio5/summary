```java
@Test
void reflection0() {
Hello target = new Hello();

// 공통 로직1 시작
log.info("start");
String result1 = target.callA();
log.info("result={}", result1);
// 공통 로직1 종료

// 공통 로직2 시작
log.info("start");
String result2 = target.callB();
log.info("result={}", result1);
// 공통 로직2 종료

}

@Slf4j
static class Hello {
public String callA() {
log.info("callA");
return "A";
}

public String callB() {
log.info("callB");
return "B";
}
}
```

- 공통 로직 1과 공통 로직2는 호출하는 핵심 기능만 다르고 부가 기능들의 코드 흐름이 완전히 같다.
- 먼저 `start`로그를 출력한다
- 핵심 기능을 호출한다.
- 메서드의 호출 결과를 로그로 출력한다.
- 여기서 공통 로직1 과 공통 로직2 를 하나의 메서드로 뽑아서 합치려고해도 코드 흐름상 핵심 기능이 중간에서 호출이 되기에 많이 어려워진다.
- 이럴 때 사용하는 기술이 바로 리플렉션인데, 리플렉션은 클래스나 메서드의 메타정보를 사용해서 동적으로 호출하는 메서드를 변경할 수 있다.

```java
@Test
void reflection2() throws Exception {
// 클래스 정보
Class<?> classHello = Class.forName("hello.proxy.jdkdynamic.ReflectionTest$Hello");

Hello target = new Hello();
Method methodCallA = classHello.getMethod("callA");
dynamicCall(methodCallA, target);

Method methodCallB = classHello.getMethod("callB");
dynamicCall(methodCallB, target);
}

private void dynamicCall(Method method, Object target) throws Exception {
log.info("start");
Object result = method.invoke(target);
log.info("result1={}", result);
}
```

- 이와 같이 리플렉션을 사용하면 핵심 기능과 부가 기능을 나눈 뒤 핵심 기능을 동적으로 처리할 수 있다는 장점이 있지만, 웬만한 경우에는 리플렉션 사용을 지양해야한다.
- 리플렉션은 클래스의 메타 정보를 조작할 수 있는 기능으로 주의가 필요한데, 객체지향적으로 설계를 할 때 정보를 은닉하여 캡슐화하는 방식으로 설계를 하는데, 리플렉션은 메서드 뿐만 아니라 이런 필드 더 나아가 어노테이션 등 모든 메타 데이터들을 조작할 수 있기에 이러한 규칙들이 전부 깨지게 되면서 위험한 상황이 발생할 수 있기에 리플렉션으로 사용 될 만한 공통적인 유틸 같은 것들이 아니라면 최대한 직접 리플렉션을 사용하는 방식은 지양해야한다.