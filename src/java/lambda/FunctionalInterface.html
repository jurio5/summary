- 특화 함수형 인터페이스는 의도를 명확하게 만든 조금 특별한 함수형 인터페이스
- `Predicate` : 입력O, 반환  `boolean`
- 조건 검사 및 필터링 용도로 사용
- `Operator (UnaryOperator, BinaryOperator)` : 입력 O, 반환 O
- 동일한 타입의 연산 수행, 입력과 같은 타입을 반환하는 연산 용도
- 예로 들면 `Operator<T>` 형식처럼 입력과 반환이 같은 타입인 경우


  #### Predicate가 왜 필요한가?
  - 기본적으로 자바에서 지원하는 `Funtion` 함수형 인터페이스를 이용하면, 입력 값과, 반환 값을 자유롭게 설정할 수 있기에 `Predicate`의 역할을 대체할 수 있다.
  - 그러나 `Predicate` 라는 함수형 인터페이스는 `의도를 명시적으로 드러내기 위해 정의`된 함수형 인터페이스 라는 것을 의도적으로 분명하게 나타내려고 만들어짐
  - 또는 가독성 및 유지보수성에 대한 이점이 있음, 협업 상황의 경우 다른 협업자들이 `Predicate`함수형 인터페이스를 봤을 때 `조건을 판단하는 함수`라는 의도가 정확히 전해짐

  ### Operator 란?
  - `Operator`라는 이름은 수학적인 연산자(Operator)의 개념에서 왔음
  - 수학에서 연산자는 보통 같은 타입의 값들을 받아서 동일한 타입의 결과를 반환함
  - 덧셈 연산자 = `숫자 + 숫자 -> 숫자`
  - 곱셉 연산자 = `숫자 * 숫자 -> 숫자`
  - 논리 연산자 = `boolean AND boolean -> boolean`
  - 자바에서는 수학처럼 숫자의 연산에만 사용된다기 보다는 입력과 반환이 동일한 타입의 연산에 사용할 수 있음
  - 예를 들어서 문자를 입력해서 대문자로 바꾸는 변환 (문자 -> 문자)

  #### UnaryOperator (단항 연산)

  - 하나의 피연산자(operand)에 대해 연산을 수행하는 함수형 인터페이스.
  - 입력(피연산자)과 결과(연산 결과)가 **동일한 타입**이어야 함.
  - 숫자 5를 입력하고 그 수를 제곱한 결과를 반환.
  - `String`을 입력받아 다시 `String`을 반환하면서 추가 문자열을 붙이는 작업을 수행.
  - 내부적으로 문자열을 대문자로 바꾸거나, 앞뒤에 특수문자를 붙이는 등의 변환 가능.
  -  따라서 `UnaryOperator`의 경우 입력과 반환 둘 다 `T` 타입을 이용하기 때문에 입력 및 반환 값이 같아야 함

  ### BinaryOperator (이항 연산)

  - 두 개의 피연산자(operand)에 대해 연산을 수행하는 함수형 인터페이스.
  - **같은 타입**의 두 입력을 받아, **같은 타입**의 결과를 반환해야 함.
  - 두 개의 `Integer` 값을 입력받아 더한 결과를 반환.
  - 두 개의 `Integer` 값을 입력받아 더 큰 값을 반환.
  - `BiFunction<T, T, T>`을 상속받으며, 입력값 2개와 반환 타입을 모두 같은 `T`로 고정.

  ### Operator 정리
  - `단항 연산`(입력 값 하나)이고 타입이 동일하다면 `UnaryOperator<T>` 사용
    - `이항 연산`(입력 값 두 개)이고 타입이 동일하다면 `BinaryOperator<T>` 사용
      - `Funtion` 함수형 인터페이스로 이 모든걸 대체할 수 있지만, 가장 중요한 것은 개발자의 의도와 로직 및 가독성을 위해 사용

      - 함수형 인터페이스는 정확히 하나의 추상 메서드를 가지는 인터페이스를 말함
      - 람다는 추상 메서드가 하나인 함수형 인터페이스에만 할당할 수 있다.
      - 단일 추상 메서드를 줄여서 SAM(Single Abstaract Method)이라 한다.
      - 참고로 람다는 클래스, 추상 클래스에는 할당할 수 없다. 오직 단일 추상 메서드를 가지는 인터페이스에만 할당할 수 있다.

      #### 여러 추상 메서드
      ```java
      public interface NotSamInterface {
      void run();
      void go();
      }
      ```
      - 인터페이스의 메서드 앞에는 abstract(추상)이 생략되어 있음
      - 여기에는 `run()`,`go()` 두 개의 추상 메서드가 선언되어 있음
      - 단일 추상 메서드(SAM)가 아니며, 이 인터페이스에는 람다를 선언할 수 없음

      #### 단일 추상 메서드
      ```java
      public interface SamInterface {
      void run();
      }
      ```
      - 여기에는 `run()`한 개의 추상 메서드만 선언되어 있음
      - 단일 추상 메서드(SAM) 이며, 이 인터페이스에는 람다를 할당할 수 있음
      - 단일 추상 메서드를 보장받기 위해선 다형성의 @Override 어노테이션과 같이 `@FunctionalInterface` 라는 어노테이션이 존재하며, 이 어노테이션을 이용하여 보장
      - 따라서, 람다를 사용 할 함수형 인터페이스라면 `@FunctionalInterface`를 필수로 추가