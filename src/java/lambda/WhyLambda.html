### 값 매개변수화 (Value Parameterization)
- 단순히 값을 매개변수로 받을 땐 간단하게 처리할 수 있음
```java
public static void helloJava() {
System.out.println("프로그램 시작");
System.out.println("Hello Java");
System.out.println("프로그램 종료");
}

public static void helloSpring() {
System.out.println("프로그램 시작");
System.out.println("Hello Spring");
System.out.println("프로그램 종료");
}

public static void main(String[] args) {
helloJava();
helloSpring();
}
```
- 이 기본적인 문제를 값 매개변수화 (Value Parameterization)

```java
public static void hello(String str) {
System.out.println("프로그램 시작");
System.out.println(str);
System.out.println("프로그램 종료");
}

public static void main(string[] args) {
hello("hello JAVA");
hello("hello Spring);
}
```

### 동작 매개변수화(Behavior Parameterization)
- 값 매개변수화는 간단하나, 한 가지의 코드(조각) 자체를 매개변수화 하려면 복잡해짐

```java
public static void helloDice() {
long startNs = System.nanoTime();

// 코드 조각 시작
int randomValue = new Random().nextInt(6) + 1;
System.out.println("주사위 = " + randomValue);
// 코드 조각 종료

long endNs = System.nanoTime();
System.out.println("실행 시간: " + (endNs + startNs) + "ns");
}

public static void helloSum() {
long startNs = System.nanoTime();

// 코드 조각 시작
for (int i = 1; i <= 3; i++) {
System.out.println("i = " + i);
}
// 코드 조각 종료

long endNs = System.nanoTime();
System.out.println("실행 시간: " + (endNs + startNs) + "ns");
}

public static void main(String[] args) {
helloDice();
helloSum();
}
```
- 여기서 중복되는 나노초를 계산하는 부분을 코드 조각과 나눠야한다.
- 다형성을 이용해서 분리하는 방법

```java
public interface Procedure() {
void run();
}
```
- 인터페이스를 하나 생성한다.

```java
public static void hello(Procedure procedure) {
long startNs = System.nanoTime();

// 코드 조각 시작
procedure.run();
// 코드 조각 종료

long endNs = System.nanoTime();
System.out.println("실행 시간: " + (endNs + startNs) + "ns");
}

static class Dice implements Procedure {
@Override
public void run() {
int randomValue = new Random().nextInt(6) + 1;
System.out.println("주사위 = " + randomValue);
}
}

static class Sum implements Procedure {

@Override
public void run() {
for (int i = 1; i <= 3; i++) {
System.out.println("i = " + i);
}
}

public static void main(String[] args) {
Dice dice = new Dice();
Sum sum = new Sum();

hello(Dice);
hello(sum);
}
}
```
- 정적 중첩 클래스를 이용해서 내부에 클래스를 만든 뒤 다형성을 이용하여 해결할 수 있음
- 또는 익명 클래스를 통해서도 해결이 가능하다.

```java
public static void hello(Procedure procedure) {
long startNs = System.nanoTime();

// 코드 조각 시작
procedure.run();
// 코드 조각 종료

long endNs = System.nanoTime();
System.out.println("실행 시간: " + (endNs + startNs) + "ns");
}

public static void main(String[] args) {
Procedure dice = new Procedure() {
@Override
public void run() {
for (int i = 1; i <= 3; i++) {
int randomValue = new Random().nextInt(6) + 1;
System.out.println("주사위 = " + randomValue);
}
}
});
}

Procedure sum = new Procedure() {
@Override
public void run() {
for (int i = 1; i <= 3; i++) {
System.out.println("i = " + i);
}
}
};

hello(dice);
hello(sum);
```
- 물론 hello 메서드(함수) 안에 바로 `inline variable`을 통하여 한 번에 생성할수도 있음
- 익명 클래스를 람다 방식으로 처리할 수 있음

```java
public static void hello(Procedure procedure) {
long startNs = System.nanoTime();

// 코드 조각 시작
procedure.run();
// 코드 조각 종료

long endNs = System.nanoTime();
System.out.println("실행 시간: " + (endNs + startNs) + "ns");
}

public static void main(String[] args) {
hello(() -> {
int randomValue = new Random().nextInt(6) + 1;
System.out.println("주사위 = " + randomValue);
});

hello(() -> {
for (int i = 1; i <= 3; i++) {
System.out.println("i = " + i);
}
});
}
```