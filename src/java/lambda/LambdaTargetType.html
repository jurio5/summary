- 람다는 그 자체만으로는 구체적인 타입이 정해져 있지 않고, `타겟 타입`(target type)이라고 불리는 맥락(대입되는 참조형)에 의해 타입이 결정된다.

```java
FunctionA functionA = i -> "value = " + i;
```
- 여기서 `i -> "value = " + i` 에서 타입이 정해지는게 아닌, functionA 변수에 대입되는 순간 타입이 정해짐 (`FunctionA`)
- 정리하면, 람다는 그 자체만으로는 구체적인 타입이 정해져 있지 않고, 대입되는 함수형 인터페이스(타켓 타입)에 의해 비로소 타입이 결정된다.
- 타입이 결정되고 나면 이후에는 다른 타입에 대입하는 것이 불가능하다. 이후 함수형 인터페이스를 다른 함수형 인터페이스에 대입하는 것은 타입이 서로 다르기 때문에, 메서드의 시그너착 같아도 대입이 되지 않는다.

```java
FunctionA functionA = i -> "value = " + i;
FunctionB functionB = i -> "value = " + i;

FunctionB functionB = functionA; // 불가능

@FunctionalInterface
interface FunctionA {
String apply(Integer i);
}

@FunctionalInterface
interface FunctionB {
String apply(Integer i);
}
```