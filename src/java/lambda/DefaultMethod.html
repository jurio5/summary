### 디폴트 메서드 등장 배경

- 자바 8에서 디폴트 메서드(default method)가 등장하기 전에는 인터페이스에 메서드를 새로 추가하는 순간, 이미 배포된 기존 구현클래스들이 해당 메서드를 구현하지 않았기 때문에 전부 컴파일 에러를 일으키게 되는 문제가 있었다. 이 때문에 특정 인터페이스를 이미 많은 클래스에서 구현하고 있는 상황에서, 인터페이스에 새 기능을 추가하려면 기존 코드를 일일이 모두 수정을 해야했다.
- 디폴트 메서드는 이러한 문제를 해결하기 위해 등장했다. 자바 8부터는 인터페이스에서 메서드 본문을 가질 수 있도록 허용해 주기 때문에, 기존 코드를 깨뜨리지 않고 새 기능을 추가할 수 있게 되었다.

### 디폴트 메서드 정리

- 자바 8에서 처음 등장한 기능
- 인터페이스 내에서 선언되는 메서드 이지만, 몸통(구현부)을 가질 수 있음
- `default`키워드를 사용
- 추가된 이유는 이미 배포된 인터페이스에 새 메서드를 추가할 때 발생하는 하위 호환성 문제를 해결하기 위함
- 사용 예시
```java
public interface MyInterface {
void existingMethod();

default void newMethod() {
System.out.println("새로 추가 된 디폴트 메서드")
}
}
```


### 디폴트 메서드의 올바른 사용법

- 디폴트 메서드는 강력한 기능이지만, 잘못 사용하면 오히려 코드가 복잡해지고 유지보수하기 어려워질 수 있다. 다음은 디폴트 메서드를 사용할 때 고려해야 할 주요 사항이다.

1. 하위 호환성을 위해 최소한으로 사용
- 디폴트 메서드는 주로 이미 배포된 인터페이스에 새로운 메서드를 추가하면서 기존 구현체 코드를 깨뜨리지 않기 위한 목적으로 만들어졌다.
- 새 메서드가 필요한 상황이고, 기존 구현 클래스가 많은 상황이 아니라면, 원칙적으로는 각각 구현하거나, 또는 추상 메서드를 추가하는 것을 고려하자
- 불필요한 디폴트 메서드 남용은 코드 복잡도를 높일 수 있다.

2. 인터페이스는 여전히 추상화의 역할
- 디폴트 메서드를 통해 인터페이스의 로직을 넣을 수 있다 하더라도, 가능하면 로직은 구현 클래스나 별도 클래스에 두고, 인터페이스는 계약(Contract)의 역할에 충실한 것이 좋다.
- 디폴트 메서드는 어디까지나 하위 호환을 위한 기능이나, 공통으로 쓰기 쉬운 간단한 로직을 제공하는 정도가 가장 이상적이다.

3. 다중 상속(충돌) 문제
- 하나의 클래스가 여러 인터페이스를 동시에 구현하는 상황에서, 서로 다른 인터페이스에 동일한 시그니처의 디폴트 메서드가 존재하면 충돌이 일어난다.
- 이 경우 구현 클래스에서 반드시 메서드를 재정의해야 한다. 그리고 직접 구현 로직을 작성하거나 또는 어떤 인터페이스의 디폴트 메서드를 쓸 것인지 명시해 주어야 한다.
- 사용 예시

```java
interface A
default void hello() {
...
}

interface B
default void hello() {
...
}

public class MyClass implement A, B {

@Override
public void hello() {
// 반드시 충돌을 해결해야 함
// 1. 직접 구현
// 2. A.super.hello();
// 3. B.super.hello();
}
}
```

4. 디폴트 메서드에 상태(state)를 두지 않기
- 인터페이스는 일반적으로 상태 없이 동작만 정의하는 추상화 계층이다.
- 인터페이스에 정의하는 디폴트 메서드도 "구현"을 일부 제공할 뿐, 인스턴스 변수를 활용하거나, 여러 차례 호출 시 상태에 따라 동작이 달라지는 등의 동작은 지양해야 한다.
- 이런 로직이 필요하다면 클래스(추상 클래스 등)로 옮기는 것이 더 적절하다.

