# 내부 조인 (INNER JOIN)

## 1. 조인이 필요한 이유

- 데이터베이스는 **정규화(Normalization)** 과정을 통해 테이블을 분리한다.
→ 중복을 줄이고, 데이터의 일관성을 유지하기 위해서.

- 만약 고객·상품·주문 데이터를 하나의 테이블(`all_in_one`)에 다 넣는다면?

### 발생하는 문제 (이상 현상, Anomalies)

1. **데이터 중복 (Redundancy)**
- 고객 정보가 주문할 때마다 반복 저장 → 저장 공간 낭비

2. **갱신 이상 (Update Anomaly)**
- 고객 이메일 변경 시, 여러 행을 전부 수정해야 함

- 일부만 수정되면 데이터 불일치 발생

3. **삽입 이상 (Insertion Anomaly)**
- 주문이 없는 상품은 테이블에 삽입 불가

- 주문과 무관한 정보까지 강제로 넣어야 함

- → 데이터를 삽입할 때 불필요한 데이터까지 함께 삽입되는 문제

4. **삭제 이상 (Deletion Anomaly)**
- 주문 기록 하나를 삭제했는데 고객 정보까지 함께 사라짐

- → 튜플을 삭제할 때 의도치 않게 연쇄적으로 데이터가 삭제되는 문제


- 이런 문제 때문에 **정규화**가 필요하며, 데이터는 `users`, `products`, `orders`로 나누어 저장한다. 하지만 분리된 데이터를 다시 모아야 할 때 **JOIN**이 필요하다.

## 2. 내부 조인의 개념

- 두 테이블의 **교집합**만 결과로 반환

```sql
SELECT 컬럼1, 컬럼2 ... FROM 테이블A JOIN 테이블B ON 테이블A.컬럼 = 테이블B.컬럼;
```
- `INNER`는 생략 가능 → 실무에서는 보통 `JOIN`만 사용

## 3. 내부 조인의 처리 순서

1. **FROM / JOIN**: 두 테이블을 ON 조건으로 결합 → 가상 테이블 생성
2. **WHERE**: 조건 필터링 (예: 상태 = 'COMPLETED')
3. **SELECT**: 원하는 컬럼만 선택

## 4. 옵티마이저(Query Optimizer)

- 실제 DBMS는 논리 순서대로 실행하지 않고, **최적화된 실행 계획**으로 처리
- 예: 먼저 `WHERE status='COMPLETED'` 조건으로 `orders`를 줄인 뒤, `users`와 조인
- 실행 계획은 달라도 **결과는 동일**

## 5. 집합 관점

- `INNER JOIN` = 두 집합의 **교집합**
```sql
orders.user_id = {1,2,3,4,5}
users.user_id = {1,2,3,4,5,6}

결과 = `{1,2,3,4,5}`
```
- 주문 없는 고객(6번)은 제외됨

## 6. 조인 방향

```sql
orders JOIN users = users JOIN orders
```
- 내부 조인은 **순서가 달라도 결과가 동일**

## 7. 실무 팁

- **테이블 별칭**으로 가독성 향상
- `orders o JOIN users u` 형식 선호 (별칭)
- **AS 생략 규칙**
- 테이블 별칭: 보통 생략
- 컬럼 별칭: 가독성을 위해 `AS` 유지
- `ex) SELECT salary * 12 as annual_salary FROM employees e`

## 정리

- **정규화**: 데이터 중복 제거 + 이상 현상 방지
- 갱신 이상(Update)
- 삽입 이상(Insertion)
- 삭제 이상(Deletion)
- **내부 조인**: 교집합, 공통 데이터만 결합
- **논리적 처리 순서**: `FROM/JOIN → WHERE → SELECT`
- **옵티마이저**: 내부적으로 실행 계획 최적화
- **조인 방향**: 순서 상관없이 결과 동일
- **실무 팁**: 테이블 별칭은 `AS` 생략, 컬럼 별칭은 `AS` 유지