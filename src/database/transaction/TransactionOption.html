
### value, transactionManager

- 기본적으로 스프링에서 트랜잭션 매니저를 통해 커넥션을 생성해주기에 기본 값을 사용하면 되는데, 트랜잭션 매니저가 둘 이상이라면 직접 스프링 빈의 이름을 적어줘야한다.
- 사용할 트랜잭션 매니절르 지정할 때는 `value`, `transactionManager` 둘 중 하나를 사용하여 트랜잭션 매니저의 스프링 빈의 이름을 적어주면 된다.

### rollbackFor

- 기본적으로 예외 발생 시 스프링 트랜잭션의 기본 정책은 다음과 같다.
- 언체크 예외인 `RuntimeException`, `Error`와 그 하위 예외가 발생하면 롤백한다.
- 체크 예외인 `Exception`과 그 하위 예외들은 커밋한다.
- 이 옵션을 사용하면 기본 정책에 추가로 어떤 예외가 발생할 때 롤백할지 지정할 수 있다.
```java
@Transactional(rollbackFor = Exception.class)
```
- 이렇게 지정하면 체크 예외인 `Exception`과 그 하위 예외들이 발생해도 롤백하게 된다.


### noRollbackFor

- `rollbackFor`와 반대이다. 기본 정책에 추가로 어떤 예외가 발생했을 때 롤백하면 안 되는지 지정할 수 있다.

### propagation

- 트랜잭션을 각각 사용하는게 아닌, 트랜잭션이 이미 진행 중인데 여기에 추가로 트랜잭션이 수행된다면?
- 기존 트랜잭션과 별도의 트랜잭션을 진행해야 하는지? 아니면 기존 트랜잭션을 그대로 이어 받아서 트랜잭션을 수행해야 하는지를 결정하는 것을 트랜잭션 전파(propagation)이라 한다.
- 스프링은 이 경우 기본 동작 방식을 외부 트랜잭션과 내부 트랜잭션을 묶어서 하나의 트랜잭션으로 만들어준다.
- 여기서 외부 트랜잭션은 처음 시작되는 트랜잭션이고 트랜잭션이 시작되는 중 트랜잭션이 한 번 더 실행되면 이걸 내부 트랜잭션이라 한다.
- 이런 외부 트랜잭션은 물리 트랜잭션 즉, 실제로 트랜잭션 매니저가 `setAutoCommit`을 `false`로 두고 트랜잭션을 시작할 때를 말하고, 논리 트랜잭션은 이 물리 트랜잭션 내부에서 트랜잭션이 실행되는 것을 의미한다. (더 정확히는 `REQUIRED` 전파 옵션을 사용하는 경우 나타난다.)
- **원칙**
- 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.
- 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.

#### 전파(propagation) 정리

- 이러한 상황이 있다고 가정하자. 일단, 외부 트랜잭션이 있고, 이 외부 트랜잭션 내부에는 트랜잭션이 한 번 더 시작되어 내부 트랜잭션이 존재한다.
- **대원칙을 한 번 더 상기를 시켜보면, 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.**
- **하나의 논리 트랙잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.**
- 조금 더 큰 범위이긴 하지만, 여기서 말하는 물리 트랜잭션은 외부 트랜잭션이고, 논리 트랜잭션은 내부 트랜잭션이다.
- 트랜잭션 구조를 조금 설명해보면, 클라이언트에서 요청을 보내면 트랜잭션이 시작되고 트랜잭션이 시작될 때 기존 객체를 트랜잭션 AOP 프록시로 동적 생성한 프록시 객체가 생성이되며 스프링은 이 객체를 빈으로 등록하여 관리를 한다.
- 여기서 헷갈릴만한 부분을 한 가지 짚고 넘어가면, 내부 호출의 문제와 헷갈릴 수 있는데 이 내부 호출의 문제는 위의 설명처럼 트랜잭션이 적용 된 메서드를 같은 인스턴스 내부에서 트랜잭션이 적용되지 않은 메서드가 호출 시 동적으로 생성 된 프록시 객체가 아닌 현재의 인스턴스 참조 객체를 호출하기에 생겨나는 문제이고, 지금 전파에서 말 하는 내부 트랜잭션, 외부 트랜잭션은 서로 트랜잭션이 적용 된 메서드 끼리의 연관 관계에서 나타나는 문제를 말 하는 것을 기본 전제로 깔고 들어간다.
- 다시 본론으로 돌아가면, 클라이언트에서 요청을 보내면 트랜잭션이 붙은 메서드에서 트랜잭션을 시작하고, 스프링 빈에 자동으로 등록되어있는 트랜잭션 매니저와 데이터 소스를 통해 커넥션을 만들어서 트랜잭션을 시작하고 트랜잭션 동기화 매니저에 커넥션을 보관한다.
- 외부 트랜잭션이 있고, 그 안에 내부 트랜잭션이 시작되고 있는 상태이다. 이 상태에서 내부 트랜잭션에서 롤백이 되고 외부 트랜잭션에서 커밋이 된다면? 혹은 내부 트랜잭션에서 커밋이 되고, 외부 트랜잭션에서 롤백이 된다면? 이 부분은 고민 할 필요도 없는게 앞서 설명한 대원칙을 생각해보면 쉽게 답을 떠올릴 수 있다.
- 대원칙에선 같은 내용이긴 하지만, 외부 트랜잭션, 논리 트랜잭션 모두 커밋이 되거나, 같은 말이긴 하지만 논리 트랜잭션 중 하나라도 롤백이 된다면 모두 롤백으로 처리된다. 라는 대원칙이 있는데 이 정도면 이야기를 해도 위의 물음에 답을 할 수 있을 것이다.
- 한 가지 더 보충 설명을 해야 할 부분은 외부 트랜잭션에서 직접적으로 물리 트랜잭션 즉, 실제로 DB에 데이터를 관리하는 역할을 수행할 수 있는데 내부 트랜잭션 쪽에서 커밋이 된다고 해도, 실제 그 위치에서 저장이 되지 않고, 내부 트랜잭션은 외부 트랜잭션에 종속적인 관계여서 외부 트랜잭션에서 커밋 혹은 롤백이 진행되면 그 결과를 따르게된다.
- 더 쉽게 풀이하면, 내부 트랜잭션은 비즈니스 로직을 통해서 데이터를 변경하고 로직이 끝난 상태에서 커밋이 진행될텐데, 그 순간 진행이 되는게 아니라 `isNewTransaction()`같은 메서드를 통해 신규 트랜잭션인지 확인 후 신규 트랜잭션이 아니라면, 외부 트랜잭션에 그 권한을 위임하여 외부 트랜잭션에서 커밋 혹은 롤백의 권한을 수행하게 된다는 것이다.
- 이런 예외의 경우도 있다. 내부 트랜잭션에서 롤백을 수행하고, 외부 트랜잭션에서 커밋이 되는 상황이 올 수 있다. 이 경우에도 대원칙에 따르면 쉽게 이 문제를 이해할 수 있지만, 내부 동작으로 하는 행동이 따로 있는데, 내부 트랜잭션에서 롤백이 생기면 스프링에서는 신규 트랜잭션이 아닌 트랜잭션에서 롤백이 발생했다 라는 표시로 `rollback-only`를 `true`상태로 변경하고, 외부 트랜잭션에서 커밋이 진행될 때 트랜잭션 동기화 매니저에서 `rollback-only`의 상태를 확인 후 `true`상태라면 `UnexpectedRollbackException`을 던져주고 결과적으로 롤백이 된다.
- 이 `UnexpectedRollbackException` 예외를 던져주는 이유는, 정상적으로 커밋은 되어서 고객이 실제로 성공 메시지를 전달 받았는데, 결과적으로 문제가 생겼음을 가시성있게 인지할 수 없으니 이런 경우에 사용하라고 던져주는 예외라고 생각하면 된다.
- 정리하면 대원칙에 따라 모두 커밋이 되어야 커밋이 진행되고, 내부 트랜잭션 중 하나라도 롤백이 된다면 전부 롤백을 하게 된다.
- 이 부분을 해결할 수 있는 방법은 트랜잭션 전파 옵션에 있다.

#### 트랜잭션 전파 옵션

- `PROPAGATION_REQUIRED(기본 값)` : 가장 많이 사용하는 기본 설정이다. 기존 트랜잭션이 없으면 생성하고, 있으면 참여한다.
- `PROPAGATION_REQUIRES_NEW` : 기존 트랜잭션을 무시하고 새로운 커넥션을 만들고, 신규 트랜잭션을 생성한다.
- 이 옵션을 사용하면, 물리 트랜잭션이 명확하게 분리된다.
- 주의해야 할 부분은 데이터베이스 커넥션이 동시에 2개가 사용된다는 점을 주의해야하는데, 만약 커넥션 풀로 예로 들면 커넥션 풀이 2개가 있다고 가정한다. 이 상황에서 `스레드A`가 외부 트랜잭션에서 커넥션을 하나 사용한 뒤 내부 트랜잭션이 `REQUIRES_NEW` 전파 옵션을 통해 새로운 커넥션을 만들고 트랜잭션을 생성하면, 총 2개의 커넥션 풀이 사용되고 있다. 이 상황에서 다른 유저가 들어와서 물리 트랜잭션을 만드려고 하는데 대기하고 있는 커넥션 풀이 존재하지 않아서 데드락 까진 아니고, 커넥션 풀 고갈 문제가 생기게 된다.
- `SUPPORT` : 트랜잭션을 지원한다는 뜻이다. 기존 트랜잭션이 없으면, 없는대로 진행하고, 있으면 참여한다.
- 기존 트랜잭션 없음 : 트랜잭션 없이 진행
- 기존 트랜잭션 있음 : 기존 트랜잭션에 참여
- `NOT_SUPPORT` : 트랜잭션을 지원하지 않는다는 의미이다.
- 기존 트랜잭션 없음 : 트랜잭션 없이 진행
- 기존 트랜잭션 있음 : 트랜잭션 없이 진행 (기존 트랜잭션은 보류)
- `MANDATORY` : 의무사항이다. 트랜잭션이 반드시 있어야 한다. 기존 트랜잭션이 없으면 예외가 발생한다.
- 기존 트랜잭션 없음 : `IllegalTransactionStateException` 예외 발생
- 기존 트랜잭션 있음 : 기존 트랜잭션에 참여
- `NEVER` : 트랜잭션을 사용하지 않는다는 의미이다. 기존 트랜잭션이 있으면 예외가 발생한다. 기존 트랜잭션도 허용하지 않는 강한 부정의 의미로 이해하면 된다.
- 기존 트랜잭션 없음 : 트랜잭션 없이 진행
- 기존 트랜잭션 있음 : `IllegalTransactionStateException` 예외 발생
- `NESTED` :
- 기존 트랜잭션 없음 : 새로운 트랜잭션 생성
- 기존 트랜잭션 있음 : 중첩 트랜잭션을 생성
- 중첩 트랜잭션은 외부 트랜잭션의 영향을 받지만, 중첩 트랜잭션은 외부에 영향을 주지 않음
- 중첩 트랜잭션이 롤백 되어도 외부 트랜잭션은 커밋할 수 있음
- 외부 트랜잭션이 롤백 되면 중첩 트랜잭션도 함께 롤백
- `JDBC savepoint`기능을 사용하므로 DB 드라이버에서 해당 기능을 지원하는지 확인 필요
- `JPA`에선 중첩 트랜잭션은 사용할 수 없음
#### 트랜잭션 전파와 옵션

- `isolation`,`timeout`,`readOnly`는 트랜잭션이 처음 시작될 때만 적용된다.
- 트랜잭션에 참여하는 경우에는 적용되지 않는다.
- 예를 들어서 `REQUIRED` 를 통한 트랜잭션 시작, `REQUIRES_NEW`를 통한 트랜잭션 시작 시점에만 적용

#### 트랜잭션 전파 예외 처리

- 기본적으로 내부 트랜잭션에서 언체크 예외로 인하여 롤백이 되면, 외부 트랜잭션에서 그 예외를 잡아서 처리를 하려고 할텐데, 이 케이스는 정상적인 흐름으로 바꾼다고해도 롤백된다.
- 그 이유는 기본적으로 트랜잭션 전파의 대원칙을 다시 상기시켜보면, 모든 트랜잭션이 커밋이 되어야 물리 트랜잭션이 커밋된다. 라는 원칙이 있다. 이게 무슨 뜻이냐면, 내부 트랜잭션에서 어떠한 이유로 인하여 롤백이 되는 순간 이 물리 트랜잭션의 `rollbackOnly` 은 `true`상태로 변하고, 이 말 즉슨 결국 외부 트랜잭션까지 올라와서 에외를 잡아서 정상 흐름으로 바꿔도 이미 `rollbackOnly` 상태가 `true`로 명시되어 있기에 결과적으로 롤백되게 된다.

### isolation

- 트랜잭션 격리 수준을 지정할 수 있는데, 기본 값은 DB에서 설정한 격리 수준인 `DEFAULT`를 그대로 사용한다.
- 트랜잭션 간의 **동시성 문제(예: 더티 리드, 반복 가능하지 않은 읽기 등)**를 제어하고 싶을 때 격리 수준을 조정한다.

| 수준               | 설명                              |
| ---------------- | ------------------------------- |
| READ_UNCOMMITTED | 커밋되지 않은 데이터도 읽을 수 있음 (가장 낮은 수준) |
| READ_COMMITTED   | 커밋된 데이터만 읽음                     |
| REPEATABLE_READ  | 트랜잭션 동안 같은 데이터를 반복해서 읽을 수 있음    |
| SERIALIZABLE     | 가장 높은 수준, 완전한 직렬화 보장            |

### timeout

- 트랜잭션 수행 시간에 대한 타임아웃을 초 단위로 지정하는데, 운영 환경에 따라 동작하는 경우도 있고, 그렇지 않은 경우도 있기에 꼭 확인하고 사용해야 한다.
- `timeoutString`도 있는데, 숫자 대신 문자 값으로 지정할 수 있다.

### readOnly

- 트랜잭션은 기본적으로 읽기 쓰기가 모두 가능한 트랜잭션이 생성된다.
- `readOnly = true`옵션을 사용하면 읽기 전용 트랜잭션이 생성된다.
- 이 경우 등록, 수정, 삭제가 안 되고 조회 기능만 작동하며 성능 미비하게 향상되면서 조회만 하는 트랜잭션이다. 라는 의도를 전달할 수 있다.
- 요즘은 객체 레벨에 트랜잭션 어노테이션을 `readOnly = true`로 걸어두고, 따로 쓰기 옵션이 필요한 메서드에만 트랜잭션 어노테이션을 부착하여 쓰기 및 읽기 옵션을 활성화 해준다.
- `readOnly`옵션은 크게 3곳에서 적용된다.

1. **프레임워크**
- `JdbcTemplate`은 읽기 전용 트랜잭션 안에서 쓰기 작업 시 예외를 던진다.
- `JPA(하이버네이트)`는 읽기 전용 트랜잭션의 경우 커밋 시점에 플러시를 호출하지 않는다.
- 읽기 전용이니 변경에 사용되는 플러시를 호출 할 필요가 없고 추가로 변경이 필요 없으니 변경 감지를 위한 스냅샷 객체도 생성하지 않아서 최적화가 발생한다.

2. **JDBC 드라이버**
- DB와 드라이버 버전에 따라서 다르게 동작하기 때문에 사전에 확인이 필요하다.
- 읽기 전용 트랜잭션에서 변경(쓰기)쿼리가 발생하면 예외를 던진다.

3. **데이터베이스**
- 데이터베이스에 따라 읽기 전용 트랜잭션의 경우 읽기만 하면 되므로, 내부에서 성능 최적화가 발생한다.