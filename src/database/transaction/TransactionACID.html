#### 트랜잭션의 개념

- 데이터를 저장할 때 단순히 파일에 저장해도 되는데 데이터베이스에 저장하는 이유는 여러가지 이유가 있지만, 가장 대표적인 이유는 데이터베이스는 `트랜잭션`이라는 개념을 지원하기 때문이다.
- 트랜잭션을 이름 그대로 번역하면 "거래"라는 뜻으로 이것을 풀어서 이야기하면, 데이터베이스에서 트랜잭션은 하나의 거래를 안전하게 처리를하도록 보장해주는 것을 뜻한다. 그런데 하나의 거래를 안전하게 처리하려면 생각보다 고려해야 할 점이 많다.
- 예를 들어서 `A`의 "5000"원을 `B`에게 계좌이체한다고 생각해보자 (`A`잔고 "5000"원 감소", `B`잔고 "5000"원 증가)
1. `A`의 잔고를 "5000"원 감소
2. `B`의 잔고를 "5000"원 증가
- 계좌이체라는 거래는 이렇게 2가지 작업이 합쳐져서 원자적으로 동작해야한다. 만약 1번은 성공했는데 2번에서 시스템에 문제가 발생하면 계좌이체는 실패하고, `A`잔고만 "5000"원 감소하는 심각한 문제가 발생한다. 데이터베이스가 제공하는 트랜잭션 기능을 사용하면 1,2 둘 다 함께 성공해야 저장하고, 중간에 하나라도 실패하면 거래 전의 상태로 돌아갈 수 있다. 만약 1번은 성공했는데 2번에서 시스템에 문제가 발생하여 계좌이체는 실패하고, 거래 전의 상태로 완전히 돌아갈 수 있다. 이러면 결과적으로 `A`의 잔고가 감소하지 않는다.
- 모든 작업이 성공해서 데이터베이스에 정상 반영하는 것을 커밋(`commit`)이라 하고, 작업 중 하나라도 실패해서 거래 이전으로 되돌리는 것을 롤백(`Rollback`)이라 한다.

#### 트랜잭션 ACID
- `원자성(Atomicity)` : 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것 처럼 모두 성공하거나 모두 실패해야한다.
- `일관성(Consistency)` : 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야한다.
- 예를 들면 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
- `격리성(Isolation)` : 동시에 실행되는 트랜잭션들이 서로에게 영향이 미치지 않도록 격리한다.
- 예를 들면 동시에 같은 데이터를 수정하지 못 하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택할 수 있다.
- `지속성(Durability)` : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.
- 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

##### 트랜잭션 격리 수준 - Isolation level
- `READ UNCOMMITED` (커밋되지 않은 읽기)
- `READ COMMITTED` (커밋된 읽기, 일반적으로 가장 많이 사용)
- `REPEATABLE READ` (반복 가능한 읽기)
- `SERIALIZABLE` (직렬화 기능)

# 트랜잭션 요약 정리

## 트랜잭션이 필요한 이유

- 데이터 변경 과정에서 일부만 성공하면 **데이터 일관성이 깨짐**
- 예시: 주문 생성(INSERT)은 성공했지만, 재고 감소(UPDATE)는 실패한 경우 → 초과 판매 발생
- **트랜잭션(Transaction)** = 논리적으로 쪼갤 수 없는 작업 묶음 (Unit of Work)
- 원칙: **All or Nothing (전부 아니면 전무)**
## 커밋(Commit), 롤백(Rollback)

트랜잭션을 제어하는 핵심 명령어:
- `START TRANSACTION` : 트랜잭션 시작 (또는 `begin`)
- `COMMIT` : 모든 작업 성공 시 변경 내용을 영구 저장
- `ROLLBACK` : 오류 발생 시 모든 변경을 취소하고 원래 상태로 복구

- **시나리오 1 (성공 → COMMIT)**
A → B 계좌로 송금 시, 출금 + 입금 모두 성공 → COMMIT으로 확정

- **시나리오 2 (실패 → ROLLBACK)**
출금만 성공 후 오류 발생 시, ROLLBACK으로 원상 복구

- MySQL은 기본적으로 `autocommit` 모드 → 여러 쿼리를 묶으려면 `START TRANSACTION` 필요
- **세션**은 데이터베이스 클라이언트(`MySQL Workbench, DBeaver`)가 데이터베이스 서버에 연결되는 순간부터 연결을 종룧라 때까지의 논리적인 연결 단위를 말하고, 각 세션은 독립적인 작업 공간을 가지며, 한 세션에서 시작된 트랜잭셔은 해당 세션 내에서만 휴효하다.

## 트랜잭션의 ACID 속성

1. **Atomicity (원자성)**: 전부 성공하거나 전부 실패해야 함
2. **Consistency (일관성)**: 트랜잭션 완료 후에도 DB는 유효한 상태 유지
3. **Isolation (격리성)**: 트랜잭션 중간 결과를 다른 트랜잭션이 볼 수 없음
4. **Durability (지속성)**: COMMIT된 결과는 장애 발생에도 영구 보존

## 트랜잭션 격리 수준 (Isolation Level)

트레이드오프: **데이터 정합성 vs 성능**
### 동시성 문제 유형

- **Dirty Read**: 한 트랜잭션이 `COMMIT`되지 않은, 수정 중인 데이터를 다른 트랜잭션이 읽을 떄
- 대부분 `REPEATABLE READ`격리 수준을 사용하기에 이 문제는 고립성을 통해 막을 수 있기에 잘 발생하지 않음
- **Non-Repeatable Read**: 같은 쿼리를 반복했을 때 값이 달라짐
- 트랜잭션 내부에서 `SELECT`를 수행하고 작업을 하던 중, 다른 트랜잭션에서 해당 데이터를 수정하면 동일 트랜잭션 내에서 다시 조회했을 때 다른 값을 읽게 됨.
- **`REPEATABLE READ`** 격리 수준에서는 발생하지 않음.
- 애플리케이션 단에서는 트랜잭션 매니저와 트랜잭션 동기화 매니저가 **커넥션과 트랜잭션 범위를 관리**하지만, Non-Repeatable Read 자체를 방지하는 것은 DB 격리 수준이 담당함.
- **Phantom Read**: 조회 범위에 새로운 행(유령 데이터)이 나타남
- `REPEATABLE READ`는 읽기 단위의 일관성 문제를 해결할 수 있으나, Phantom Read와 같은 **범위 단위의 동시성 문제**는 원천적으로 막을 수 없음.
- 완벽하게 방지하려면 **`SERIALIZABLE`** 격리 수준이 필요함.
- **애플리케이션 단에서 관리 여부**
- 트랜잭션 매니저는 트랜잭션 범위와 커넥션 관리를 담당할 뿐, Phantom Read 발생 자체를 막을 수는 없음.
- Phantom Read는 주로 DB에서 SQL을 직접 수행할 때 발생하는 범위 단위 동시성 문제임.
- 다만, 실제로는:
- 고객이 직접 SQL을 날릴 가능성이 거의 없고
- Gap Lock 같은 DB 기능을 통해 범위 내 삽입/수정에 대해 자동으로 잠금을 걸기 때문에
- 결론은 **Phantom Read가 발생할 확률은 매우 낮음**
- **Gap Lock** (`MySQL InnoDB 엔진`)
- DB가 특정 범위를 기준으로 자동 잠금을 걸어, 범위 내 기존 로우와 새로 삽입될 로우를 보호하는 방식
### 4가지 표준 격리 수준

| 격리 수준            | Dirty Read | Non-Repeatable Read | Phantom Read |
| ---------------- | ---------- | ------------------- | ------------ |
| READ UNCOMMITTED | 발생         | 발생                  | 발생           |
| READ COMMITTED   | 방지         | 발생                  | 발생           |
| REPEATABLE READ  | 방지         | 방지                  | 발생(일부 방지*)   |
| SERIALIZABLE     | 방지         | 방지                  | 방지           |
- **READ UNCOMMITTED** : 성능 ↑, 정합성 ↓ (실무에서 거의 사용 X)
- **READ COMMITTED** : 오라클·SQL Server 기본값
- **REPEATABLE READ** : MySQL InnoDB 기본값 (Gap Lock 덕분에 Phantom Read도 대부분 방지)
- **SERIALIZABLE** : 정합성 ↑, 성능 ↓ (거의 사용하지 않음)
### 격리 수준 확인 및 변경
```sql
-- 현재 세션 격리 수준 확인
SELECT @@transaction_isolation;

-- 세션 단위 변경
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 전역(Global) 변경 (주의!)
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;
```
### 실무 팁

- 기본적으로 **MySQL InnoDB의 REPEATABLE READ 유지** 권장
- 트래픽이 많고 조회 위주라면 `READ COMMITTED` 고려 가능
- `READ UNCOMMITTED`는 통계/분석용 DB에서만 제한적으로 사용
- `SERIALIZABLE`은 성능 저하가 심각해 거의 사용하지 않음
## 최종 정리

- 트랜잭션은 데이터 변경 작업을 하나의 묶음으로 관리 → **All or Nothing** 보장
- 핵심 제어 명령어: `START TRANSACTION`, `COMMIT`, `ROLLBACK`
- 트랜잭션 신뢰성 = **ACID 속성** (원자성, 일관성, 격리성, 지속성)
- 격리 수준은 정합성과 성능 사이의 균형을 조절하는 장치
- MySQL 기본값 `REPEATABLE READ` 사용을 권장
- 트래픽이 매우 많고 단순 조회 위주의 웹 애플리케이션의 경우 `READ COMMITTED`를 고려할 수 있음