### DB락 개념
- 트랜잭션을 수행할 때 `세션A`가 `A`라는 멤버의 데이터를 수정하고 있고, 동시에 `세션B`가 `B`라는 멤버의 데이터를 수정하는 상황에서는 두 세션의 변경 순서를 명확히 알 수 없습니다. 만약 같은 데이터를 동시에 수정하게 되면, **어떤 세션의 결과가 최종적으로 반영되었는지 알 수 없고**, 이로 인해 **원자성이 깨질 수 있습니다**.

- 이러한 문제를 방지하기 위해, **한 세션이 트랜잭션을 시작해 데이터를 수정하는 동안에는 다른 세션이 해당 데이터에 접근하지 못하게 해야 하며**, 이는 **격리성(Isolation)**을 통해 보장됩니다.

### DB락 변경
- `세션A`가 트랜잭션을 시작하여 `update`, `insert` 등 데이터를 변경하면, 해당 데이터에 **락(Lock)**이 걸립니다.

- 이 상태에서 `세션B`가 동일한 데이터에 접근하여 변경하려고 하면, 이미 `세션A`가 락을 점유하고 있으므로 `세션B`는 **대기 상태**에 들어갑니다.

- 이후 `세션A`가 작업을 마치고 커밋(또는 롤백)하여 락을 해제하면, `세션B`는 **락을 획득한 뒤 작업을 수행**하게 됩니다.

### 문제점
- 락과 트랜잭션을 제대로 관리하지 않으면 동시성 이슈가 생기게 되는데 이 문제를 해결하기 위해선 여러가지 방법이 있습니다.
- 락 전략 (낙관적 락 , 비관적 락)
-  **비관적 락(Pessimistic Lock)**: 먼저 락을 걸고 작업을 시작함. 충돌을 사전에 방지.
-  **낙관적 락(Optimistic Lock)**: 충돌 가능성을 낮게 보고, 갱신 시점에 버전 검사 등을 통해 충돌 여부를 판단.
- 트랜잭션 격리 수준(READ COMMITTED, SERIALIZABLE 등)
- `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE` 등 단계적으로 격리 강도를 조절.
- 트랜잭션 관리
- 명확한 트랜잭션 경계 설정, 커밋/롤백 처리, 예외 발생 시 롤백 등을 통해 일관성과 원자성 보장.

### DB 락 조회
- 일반적으로는 조회(select)를 할 때에는 락을 점유하지 않는데, 조회를 하면서 락을 획득하고 싶을때가 있다.
- 이런 경우에는 `select for update`구문을 사용하면 된다.