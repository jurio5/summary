# 서브쿼리(Subquery)

## 1. 서브쿼리 소개

- **정의**: SQL 문 안에 포함된 또 다른 `SELECT` 문.
- **실행 순서**: 서브쿼리가 먼저 실행 → 결과가 메인쿼리에 전달됨.
- **사용 이유**
- 여러 단계를 **하나의 논리 단위**로 묶어 오류/불편 감소.
- 실시간 데이터 변화에도 안전하게 처리 가능.
```sql
SELECT name, price
FROM products
WHERE price > (SELECT AVG(price) FROM products);
```

## 2. 서브쿼리의 종류

|종류|결과 형태|주요 위치|연산자|활용|
|---|---|---|---|---|
|**스칼라**|단일 행·단일 컬럼|SELECT, WHERE, HAVING|=, >, <|단일 값 비교|
|**다중 행**|여러 행·단일 컬럼|WHERE, HAVING|IN, ANY, ALL|값 목록 비교|
|**다중 컬럼**|여러 컬럼|WHERE, HAVING|(c1, c2) = ... / IN|다중 조건(튜플) 비교|
|**테이블**|여러 행·컬럼|FROM|FROM (...) AS alias|가상의 테이블 생성

## 3. 스칼라 서브쿼리 (Scalar Subquery)

- **단일 값 반환**.
- `=`, `>`, `<` 등의 비교 연산자와 함께 사용.
- 반드시 **하나의 행**만 반환해야 함. (여러 행 반환 시 `Error Code: 1242` 발생)
```sql
-- 특정 주문자와 같은 도시에 사는 고객 찾기
SELECT name, address
FROM users
WHERE address = (
SELECT u.address
FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE o.order_id = 1
);
```
- 단일 값 반환은 `PK`,`Unique` 같은 하나의 행을 반환하는 컬럼에만 사용할 수 있음

## 4. 다중 행 서브쿼리 (Multi-row Subquery)

- 여러 행 반환 가능.
- `IN`, `ANY`, `ALL` 같은 연산자 사용.

#### 1) `IN`
```sql
-- '전자기기' 카테고리 상품을 주문한 내역 조회
SELECT * FROM orders
WHERE product_id IN (
SELECT product_id FROM products WHERE category = '전자기기'
);
```

#### 2) `ANY`

- 목록 값들 중 **하나 이상**과 비교.
- `> ANY (목록)` : **최소값보다 크면 참**
- `< ANY (목록)` : **최대값보다 작으면 참**
- `= ANY (목록)` : `IN`과 동일
```sql
-- '전자기기' 상품들 중 최소 가격보다 비싼 상품 찾기
SELECT name, price
FROM products
WHERE price > ANY (
SELECT price FROM products WHERE category = '전자기기'
);
```

#### 3) `ALL`

- 목록 값들 **모두와 비교**.
- `> ALL (목록)` : **최대값보다 커야 참**
- `< ALL (목록)` : **최소값보다 작아야 참**
```sql
-- '전자기기' 상품들 중 최고가보다 더 비싼 상품 찾기
SELECT name, price
FROM products
WHERE price > ALL (
SELECT price FROM products WHERE category = '전자기기'
);
```
### 주요 연산자

- `IN`: 목록 중 하나라도 일치하면 참.
- `ANY`: 목록 **중 최소값** 기준 비교.
- `ALL`: 목록 **중 최대값** 기준 비교.

### ANY , ALL ?

- `ANY` 와 `ALL`의 경우 대부분 집계함수(`MIN`,`MAX`)로 대체가 가능하다. 실무에서는 `ANY`,`ALL` 보다는 집계함수로 처리하는게 가독성이 더 좋다.
```sql
select name, price
from products
where price > (select min(price) from products where category = '전자기기')

==

SELECT name, price
FROM products
WHERE price > ANY (
SELECT price FROM products WHERE category = '전자기기'
);
```

- 위 두 쿼리는 동일한 결과를 출력한다. `> ANY`의 경우 만약 `price`가 `100,200,300`이라면 그 중 하나라도 만족하는 이라는 뜻으로 쉽게 말하면 `> ANY` 즉, `> 100` 과 동일하다. 이 뜻은 `MIN(price)` 집계 함수도 `> ANY`와 동일한 값을 출력한다는 뜻이다.

## 5. 다중 컬럼 서브쿼리 (Multi-column Subquery)

- 서브쿼리가 **여러 컬럼을 반환**.
- `(c1, c2) = ( ... )` 또는 `(c1, c2) IN ( ... )` 형태.
```sql
-- 특정 주문과 고객/상태가 같은 주문 조회
SELECT order_id, user_id, status
FROM orders
WHERE (user_id, status) = (
SELECT user_id, status FROM orders WHERE order_id = 3
);

-- 각 고객별로 가장 먼저 한 주문의 주문ID, 사용자ID, 사용자이름, 제품이름, 주문 날짜를 조회
select o.order_id, o.user_id, u.name, p.name, o.order_date
from orders o join users u on o.user_id = u.user_id
join products p on o.product_id = p.product_id
where (o.user_id, o.order_date) in (
select user_id, min(order_date) from orders group by user_id
)
```

## 6. 상관 서브쿼리 (Correlated Subquery)

- 메인쿼리의 각 행을 읽으며, 그 값을 이용해 서브쿼리를 반복 실행.
- 독립 실행 불가, 메인쿼리와 **연관 관계**를 맺음.
```sql
-- 카테고리 별 평균 가격 이상인 상품 찾기
SELECT p1.name, p1.category, p1.price
FROM products p1
WHERE price >= (
SELECT AVG(price)
FROM products p2
WHERE p2.category = p1.category
);
```
- 주의: 행이 많을 경우 성능 저하 → 가능하면 `JOIN`으로 대체.

## 7. `IN` vs `EXISTS`

- `IN`: 서브쿼리 결과 전체를 메모리에 담아 비교.
- `EXISTS`: 행이 **존재하는지 여부만 확인** → 조건 만족 시 즉시 종료 → 큰 데이터셋에서 효율적.
```sql
-- 주문된 적 있는 상품
SELECT p.product_id, p.name, p.price
FROM products p
WHERE EXISTS (
SELECT 1 FROM orders o WHERE o.product_id = p.product_id
);
```
- `NOT EXISTS` : 반대로 **주문된 적 없는 상품** 조회.

## 8. SELECT 절 서브쿼리

- 단일 값을 반환하는 **스칼라 서브쿼리**만 가능.
- 각 행에 계산된 결과를 컬럼처럼 붙여줌.
```sql
-- 전체 평균 가격을 함께 표시
SELECT name, price,
(SELECT AVG(price) FROM products) AS avg_price
FROM products;

-- 각 상품별 주문 횟수 표시 (상관 서브쿼리)
SELECT name, price,
(SELECT COUNT(*) FROM orders o
WHERE o.product_id = p.product_id) AS order_count
FROM products p;
```


## 9. 테이블 서브쿼리 (Inline View)

- 인라인 뷰는 반드시 별칭을 가져야한다.
- `FROM (서브쿼리) AS alias`
- **가상의 테이블**을 만들어 다른 테이블과 `JOIN` 가능.
```sql
-- 카테고리별 평균 가격 구한 뒤 JOIN
SELECT p.category, p.name, p.price, c.avg_price
FROM products p
JOIN (
SELECT category, AVG(price) AS avg_price
FROM products
GROUP BY category
) c ON p.category = c.category;

---

-- 카테고리별 가장 비싼 상품의 모든 컬럼을 조회
select *
from products p join (
select category, max(price) as max_price
from products group by category) as cmp
on p.category = cmp.category and p.price = cmp.max_price
```

## 10. 서브쿼리 vs JOIN

- **JOIN**: 테이블을 수평 확장 (데이터 결합).
- **서브쿼리**: 쿼리를 단계적으로 중첩 (데이터 필터링·계산).

## 정리

- 서브쿼리는 **단계적 사고를 SQL 내부에서 직접 표현**하는 도구.
- 반드시 상황에 맞는 서브쿼리 종류와 연산자를 선택해야 함.
- 성능 문제 시 `JOIN` 또는 집계 함수로 대체하는 것도 고려.