# 인덱스 정리

## 1. 인덱스가 필요한 이유

- 데이터가 적을 땐 빠르지만, 수십만~수억 건이 되면 `풀 테이블 스캔(Full Table Scan)`으로 인해 검색 성능이 급격히 저하됨.
- 풀 테이블 스캔의 시간 복잡도: **O(n)**
- 예시: 1억 건 데이터에서 단일 검색 시 수십 초 이상 소요 가능.
-  해결책: **인덱스(Index)**

- **인덱스 활용**
- WHERE 절에 자주 쓰이는 컬럼에는 인덱스를 반드시 생성해야 함.
- 서비스 핵심 쿼리에서 풀 테이블 스캔이 나오지 않도록 설계하는 것이 필수.

- **실행 계획 확인 (`EXPLAIN`)**
- 의도치 않은 풀 테이블 스캔이 발생하는지 반드시 점검.
- `type: ALL` → 풀 테이블 스캔 경고 신호.

- **작업 시간 분리**
- 통계/배치 같은 대용량 전체 스캔은 이용자가 적은 새벽 시간대에 수행.

## 2. 인덱스의 개념

- 책의 **찾아보기(색인)** 과 동일한 개념.
- 특정 컬럼 값 + 해당 데이터의 위치를 저장하는 별도의 자료 구조.
- `ex) item_name (정렬 상태) + item_id (실제로는 참조하는 테이블이랑 연결되어 있는 레퍼런스 값) -> item_name 조회 시 item_id를 기준으로 조회하기에 속도 향상`
- 항상 **정렬된 상태** 유지.
- 검색 속도를 **O(log n)** 수준으로 향상.
#### 클러스터 인덱스 (Clustered Index)

- **기본 키(PK)** 기준으로 자동 생성되는 인덱스
- **테이블 데이터 자체가 인덱스에 포함되어 있음**
- 즉, 클러스터 인덱스 = 데이터 자체가 정렬된 구조
- 장점:
- PK 기반 검색은 매우 빠름 → 인덱스 탐색 = 곧 데이터 조회
- 단점:
- PK 값이 바뀌면 데이터 재배치 필요 (비효율적)
- 테이블당 **하나만 존재** (데이터 자체가 정렬되어 있어야 하므로)

```sql
CREATE TABLE users (
id BIGINT PRIMARY KEY AUTO_INCREMENT,  -- PK → 클러스터 인덱스 자동 생성
email VARCHAR(255) UNIQUE,
name VARCHAR(100)
);
```

#### 보조 인덱스 (Secondary Index, Non-Clustered Index)

- PK 외의 컬럼에 사용자가 직접 만든 인덱스
- 원본 데이터 대신 **PK 값을 저장**해서, PK 인덱스를 다시 타고 원본 데이터 접근
- 장점:
- PK 외 컬럼 검색 속도 개선
- 단점:
- 두 번 탐색 필요 (보조 인덱스 → PK 인덱스 → 원본 데이터)
- 따라서 PK가 길면 보조 인덱스도 크기가 커짐
```sql
-- email 컬럼에 보조 인덱스 생성
CREATE INDEX idx_users_email ON users(email);
```

#### 클러스터 vs 보조 인덱스 비교

| 구분    | 클러스터 인덱스              | 보조 인덱스          |
| ----- | --------------------- | --------------- |
| 생성    | 자동 (PK 기반)            | 수동 (사용자가 지정)    |
| 저장 내용 | PK + 실제 데이터           | 인덱스 컬럼 값 + PK 값 |
| 검색 속도 | 빠름 (한 번 탐색)           | PK까지 두 번 탐색     |
| 개수    | 테이블당 1개               | 여러 개 가능         |
| 쓰기 비용 | 상대적으로 높음 (데이터 재배치 필요) | PK 갱신 영향 받음     |
#### 실무 팁

- **PK는 신중히 선택**: 단순하고 짧은 정수형이 이상적 (BIGINT AUTO_INCREMENT)
- 보조 인덱스는 PK 값을 참조하므로 **PK가 길면 보조 인덱스 크기도 비대해짐**
- → UUID 같은 긴 문자열을 PK로 두면 비효율적
- 자주 조회하는 조건 컬럼에는 보조 인덱스 생성
- 자주 쓰기(INSERT/UPDATE/DELETE) 되는 테이블에는 인덱스 개수를 최소화
#### 정리

- **클러스터 인덱스 = 테이블 데이터 자체를 정렬한 구조 (PK 기준, 단 하나)**
- **보조 인덱스 = 추가 색인, 결국 PK 인덱스를 경유해야 원본 데이터 조회**
## 3. 인덱스의 내부 구조

- 기본적으로 **트리(Tree) 구조** 사용.
- 주요 원리:
- **이진 탐색 트리**: 좌측은 작은 값, 우측은 큰 값 → 탐색 속도 `O(log n)`
- 다만, 값이 한 쪽으로 기울어진다면(`ex)1,5,6,10,15`) 이진 탐색 트리가 편향 트리가 되면서 최악의 경우 `o(n)`의 성능이 나오고, 이는 `풀 테이블 스캔`과 동일한 성능이 된다.
- **밸런스 트리(Balanced Tree)**: 한쪽으로 치우치는 문제 해결
- 위 와 같은 문제를 해결하기 위해 RDBMS 는 내부에서 밸런스 트리 구조를 사용하여 균형을 유지하기에 최악의 경우에도 동일하게 `o(log n)`성능이 나오게 된다.
- 실제 DBMS는 **B-Tree / B+Tree** 사용 → 디스크 I/O 최소화, 대용량 데이터 최적화

## 인덱스 생성/관리

- 인덱스 이름은 보통 `idx_테이블명_컬럼명`과 같은 규칙으로 지으면 관리하기 편하다.

- 생성:
```sql
CREATE INDEX idx_items_item_name ON items (item_name);
```

- 조회:
```sql
SHOW INDEX FROM items;
```

- 삭제:
```sql
DROP INDEX idx_items_item_name ON items;
```

- 결과:
`SHOW INDEX`를 통해 확인할 수 있는 `카디널리티(Cardinality)`는 인덱스 컬럼의 **서로 다른 값이 몇 개 정도 있는지를 나타내는 통계 정보**이다. 값이 다양할수록(카디널리티가 높을수록) 인덱스를 사용한 검색 시 더 많은 레코드를 걸러낼 수 있어 효율이 높아진다. 단, MySQL이 보여주는 카디널리티는 실제 정확한 값이 아니라 **옵티마이저가 참고하는 추정치**이므로, 필요시 `ANALYZE TABLE` 명령으로 최신 통계로 갱신할 수 있다.

- 인덱스가 자동 생성되는 경우:
- **PRIMARY KEY**, **FOREIGN KEY**, **UNIQUE 제약조건**

- `UNIQUE` 제약조건이 있는 컬럼에는 자동으로 인덱스가 생성되는 이유는 예를 들어, 핸드폰 번호 컬럼에 10만 건의 데이터가 있을 때, 새로운 데이터를 추가하려면 이 값이 이미 존재하는지 확인해야 한다. 만약 `UNIQUE` 제약조건이 없다면 매번 전체 데이터를 조회해야 하므로 성능 문제가 발생할 수 있다. 따라서 유일성 검사를 효율적으로 수행하고 성능을 보장하기 위해 `UNIQUE` 제약조건에는 자동으로 인덱스가 생성된다.
- 요약을 하자면 `UNIQUE` 제약조건에는 데이터 유일성 검사를 빠르게 하기 위해 자동으로 인덱스가 생성된다.

## 인덱스 성능 확인

- `EXPLAIN` 키워드로 실행 계획 확인 가능.
- `type: ALL` → 풀 테이블 스캔
- `type: ref` → 동등 비교 인덱스 사용
- `type: range` → 범위 검색 인덱스 사용
- `key` 컬럼에서 사용된 인덱스 확인 가능
- `key` 값이 `NULL`이라면 인덱스를 사용하지 못했다는 의미

## 인덱스 동작 방식

### 동등 비교 (=, JOIN)

- 인덱스 사용 시 `type: ref`
- 풀 테이블 스캔(`ALL`) 대신 필요한 데이터만 탐색
### 범위 검색 (BETWEEN, >, <, LIKE 등)

- 인덱스 사용 시 `type: range`
- 조건에 맞는 데이터 범위만 인덱스 스캔
### LIKE 검색

- `%keyword` → 인덱스 사용 불가 (앞에 와일드카드 있을 때)
- `keyword%` → 인덱스 사용 가능
- 만약 `%keyword%`처럼 중간에 `keyword`가 포함되는 글자를 찾고싶다면 `전문 검색(Full-Text Search)`라는 특수한 기능을 사용해야한다. (`MATCH ... AGAINST`)
- 혹은 `엘라스틱 서치`같은 검색을 중심으로 한 분산형 NoSQL 데이터베이스를 사용하는 것도 방법이다.
### 정렬 (ORDER BY)

- 정렬 대상 컬럼에 인덱스 있으면 **추가 정렬 불필요**
- 이미 인덱스 작업을 하는 순간 내부적으로 정렬이 되어있는 상태라 데이터베이스는 테이블의 순서를 알고 있는 상태여서 추가적인 정렬이 불필요
- 없으면 DB가 정렬 작업 수행 → 성능 저하
- 인덱스를 통해 정렬되어 있는 내용이 아니라면 전체적으로 한 번 정렬을 한 뒤에 정렬 작업을 한 번 더 수행하기에 성능 저하
- 그러나 베스트 프랙티스는 항상 `ORDER BY`를 명시해주는게 좋음
- 인덱스를 드롭하거나, 새로운 인덱스가 추가될 때 순서를 보장할 수 없기 때문
- 인덱스를 양방향으로 정렬할 수 있기 때문에 `filesort` 작업이 일어나지 않은 상태로 `내림차순`이 가능하다. (단, `where` 조건과 `order by` 조건이 인덱스와 일치해야 함)
- 혹은 인덱스를 생성할 때 `price`가 내림차순으로 많이 사용되는 컬럼이라면 내림차순으로 설정해도 된다. (`Backward index scan`)
- `ex) create index idx_items_price on items (price desc)`
- 이렇게 내림차순을 지정하는 이유는 하드웨어는 정방향이 역방향보다 조금 더 빠르 때문인데 큰 차이는 아니다.
- 이러한 이유 때문에 정렬할 때 `filesort`가 발생하지 않아 정렬 시 극적인 성능 향상을 끌어낼 수 있고, 단일 컬럼 인덱스에선 이 역방향 스캔과 내림차순 인덱스 간의 성능 차이가 크지 않을 수 있지만, 다중 컬럼 인덱스(복합 인덱스)에선 이 내림차순 인덱스 설정을 성능을 대폭 향상시킬 수 있다.

## 주의할 점

- 인덱스는 읽기 성능을 크게 향상시키지만, **쓰기(INSERT/UPDATE/DELETE) 성능은 저하**될 수 있음.
- 불필요한 인덱스는 관리 오버헤드만 증가 → 주기적 점검 필요.
- 너무 작은 데이터셋(예: 수십 건)에서는 인덱스 대신 풀 테이블 스캔이 더 빠를 수도 있음.

## 인덱스 요약

- 인덱스 = DB 성능 최적화의 핵심
- 검색 성능을 **O(n) → O(log n)** 으로 개선
- WHERE / JOIN / ORDER BY 등에 자주 쓰이는 컬럼에 적용
- `EXPLAIN`으로 실행 계획을 반드시 점검

## 옵티마이저와 인덱스 선택

- 인덱스가 있다고 항상 사용되는 것은 아님 → 옵티마이저가 **비용 기반**으로 결정
- **손익분기점**: 전체 데이터의 약 20~25% 이상 조회 시 인덱스보다 풀 테이블 스캔이 효율적

- **랜덤 I/O vs 순차 I/O**
- 랜덤 I/O: 데이터 위치 탐색 → 느림
- 순차 I/O: 연속 읽기 → 빠름
- 적은 데이터(소형 테이블)에서는 풀 테이블 스캔이 더 효율적
- `EXPLAIN`으로 인덱스 사용 여부 항상 확인

## 커버링 인덱스 (Covering Index)

- **쿼리에 필요한 모든 컬럼을 포함하는 인덱스**
- 테이블 접근(랜덤 I/O) 없이 **인덱스만으로 결과 반환**
- `Extra: Using index` 표시 → 커버링 인덱스 사용됨
- **장점**
- 조회 성능 극적 향상
- 랜덤 I/O 가 발생하지 않음
- COUNT 최적화
- 인덱스의 크기 만큼 읽으면 되기 때문
- **단점**
- 인덱스 크기 증가
- 참조 테이블의 데이터를 그 만큼 끌고와서 사용해야 하기 때문
- 쓰기 성능 저하 (INSERT/UPDATE/DELETE 시 인덱스도 갱신 필요)
- 사용처: 읽기 많은 테이블, 특정 성능 튜닝 필요할 때

- 커버링 인덱스는 인덱스를 생성할 때 인덱스 할 컬럼을 삽입해두고, 조회 시 인덱스에 있는 내용들로 테이블을 거치지않고 인덱스 내부에서 바로 결과 값을 돌려주는 방식을 말한다.
- 예로 들어 :
```sql
create index idx_items_item_name on items (item_name);

...

select item_name from items where item_name = '노트북';
```

- 위 와 같이 `item_name`을 인덱스로 등록해두고, `select`할 때 `item_name`만 `select`하여 조회할 시 인덱스에 있는 내용을 조회하기에 `커버링 인덱스`를 할 수 있는 것이다.
- 이런 방식으로 인덱스 테이블에서 조회를 하지 않고 실제 테이블에서 조회하는 경우를 `일반 인덱스`라고 한다.

## 복합 인덱스 (Composite Index)

- **여러 컬럼을 묶어 하나의 인덱스로 생성**
- 컬럼 **순서**가 매우 중요
- **인덱스 왼쪽 접두어 규칙**
- 복합 인덱스는 첫 번째 컬럼을 기준으로 정렬된 상태에서만 제 역할을 할 수 있다.
- (A, B, C) 인덱스 → 사용 가능: (A), (A,B), (A,B,C)
- 불가능: (B), (C), (B,C)

- **대원칙**
1. 인덱스는 순서대로 사용 (왼쪽 접두어 규칙)
2. 등호(=) 조건은 앞으로, 범위 조건(<, >)은 뒤로
3. 정렬(ORDER BY)도 인덱스 순서를 따르라

- **성공 사례**
- `WHERE category = '전자기기'`
- `WHERE category = '전자기기' AND price = 120000`
- `WHERE category = '전자기기' AND price > 100000 ORDER BY price`
- 이 정렬의 경우 `category`를 제외해도 되는 이유는 `WHERE`절의 조건 결과가 하나의 카테고리만 출력되기 때문에 정렬에 의미가 없기에 `price`만 정렬을 해도 동일한 결과가 출력되는 것이고, 만약 여러가지 조건이 나오는 상황이라면 인덱스 컬럼의 순서대로 정렬을 해야한다.

- **실패 사례**
- `WHERE price = 80000` (순서 무시 → 인덱스 불가)
- `WHERE category >= '패션' AND price = 20000` (범위 조건 먼저 사용 → 뒤 컬럼 활용 불가)

## 최적화 팁

- **범위 조건 대신 IN 절 활용**
- `category >= '패션'` → `category IN ('패션', '헬스/뷰티')`
- IN은 여러 개의 `=` 조건으로 인식되어 인덱스 활용 가능
- 기존 인덱스를 최대한 재활용 → 불필요한 인덱스 남발은 쓰기 성능 저하

```sql
create index idx_category_price on items(category, price); -- 인덱스 생성

-- 범위 조건으로 먼저 검색 (인덱스를 사용하긴 하지만, 성능 최악)
select * from items where category >= '패션' and price = 20000

-- IN 절은 '=' 여러 개의 동등 비교 조건으로 인식하기 때문에 성능 향상
select * from items where category in ('패션', '헬스/뷰티') and price = 20000
```
- 물론 `IN`절에 들어가는 인자들이 많으면 성능이 저하될 수 있으니 `EXPLAIN`을 통해 지속적으로 계획들을 확인하며 사용해야한다.

## 인덱스 설계 가이드라인

- 자주 조회되는 컬럼 위주로 생성
- 카디널리티 값이 높은 곳, 예로들어 `PK`처럼 중복되지 않는 경우가 베스트 프랙티스
- 남자/여자 성별을 확인하는 컬럼처럼 도메인의 종류가 적은 값은 지양
- 즉, 인덱스는 고유성이 높은, 식별력이 좋은 컬럼에 생성할 때 효과적

- 쓰기 vs 읽기 성능 트레이드오프 고려
- 실제 테이블에 컬럼이 자주 변경되면 인덱스 테이블에도 데이터 변경되어야 하기에 많은 비용이 발생

- `WHERE`절에서 자주 사용되는 컬럼
- 인덱스의 존재 이유가 `WHERE`절의 검색 속도를 높이는 것이기 때문에 위의 내용처럼 검색 조건이 많이 사용되며, 카디널리티가 높은 값이 인덱스 대상이 되는게 베스트

- `JOIN`의 연결고리가 되는 컬럼 (외래키)
- 기본적으로 데이터베이스는 `PK`,`FK`,`UNIQUE`를 생성할 때 자동으로 인덱스를 만들어주기에 이 문제는 해결

- `ORDER BY`절에서 자주 사용되는 컬럼
- 인덱스를 사용하지 않은 `filesort` 상태일 때 `ORDER BY`절을 통해 조건을 걸고 정렬을 할 때 만약, 100만 건 정도의 데이터가 있고 여기서 가장 최근 3개의 데이터만 가져와야 한다고 가정하면 100만 건을 전부 다 정렬을 한 뒤 데이터를 가져와야한다.
- 여기서 한 명이 이 기능을 사용해도 무리가 가는데 수십 수백 수천명이 이 조회를 사용하게 된다면 과부화 문제로 서버 장애가 발생할 수 있다.
- 이러한 문제 때문에 데이터가 자주 조회되고, 데이터가 많은 컬럼에 정렬이 필요하다면 무조건 인덱스를 걸어주는게 좋다.
- B-TREE 인덱스는 이미 데이터가 정렬 된 값으로 저장되기 때문에 추가적인 정렬 작업 없이 바로 데이터를 읽기만 하면 되기 때문

- `SELECT *` 대신 필요한 컬럼만 조회 → 커버링 인덱스 활용 가능
- 항상 `EXPLAIN`으로 실행 계획 확인

## 인덱스 단점 및 주의사항

- 저장 공간 증가
- 인덱스는 컬럼의 개수나 어떻게 구성하는지에 따라 편차가 있지만 원본 테이블의 약 10% 내외의 공간을 추가로 사용한다고 알려져있는데, 100GB에 달하는 테이블에 5개의 인덱스를 사용하면 약 50GB라는 추가 디스크를 사용하는 것과 같다.

- 쓰기 성능 저하
- 인덱스의 가장 치명적인 단점인데 읽기(`SELECT`) 성능을 높이는 대가로 쓰기(`INSERT`,`UPDATE`,`DELETE`) 작업들의 속도를 희생시킨다.
- 이유는 당연히 원본 테이블의 데이터가 변경되면 인덱스의 데이터들도 추가/변경/삭제가 되어야 하기 때문이다.

- 불필요한 인덱스는 오히려 성능 악화 가능
- 데이터 분석 시스템, 블로그, 뉴스 사이트 처럼 데이터 변경보다는 조회가 훨씬 더 빈번한 읽기 중심 서비스라면, 조회 성능을 높이기 위해 인덱스를 비교적 자유롭게 생성해도 좋지만, 쓰기 중심의 서비스인 로깅 시스템, 주식 거래 시스템, 채팅 시스템 처럼 실시간으로 데이터를 기록하고 변경하는 쓰기 작업이 빈번하게 발생하는 서비스라면 인덱스 생성에 신중하고 보수적으로 접근해야한다. 모든 인덱스는 쓰기 작업에 오버헤드를 추가하기 때문에 꼭 필요한 최소한의 인덱스만 유지하자

- 쿼리 패턴을 먼저 분석하고, 필요한 최소한의 인덱스만 생성할 것
- 혹시나 하는 목적으로 설계 단계에서 모든 인덱스를 만드는 것 보다 서비스를 하면서 모니터링 후 필요하다 생각이 되는 경우에 인덱스를 생성하는 방식을 지향하지만, 그렇다고 설계하는 단계에서 인덱스를 전부 걸지말아라 라는 뜻이 아니라 서비스를 하다보면 어느정도 데이터가 있을거고, 눈에 보이는 기능들 중 조회 기능이 빈번하게 발생할 것 같다. 라는 부분에서는 인덱스를 걸어도 괜찮다.

- 사용하지 않는 인덱스는 주기적으로 정리하라
- 대부분의 데이터베이스는 특정 인덱스가 얼마나 사용되었는지 모니터링하는 기능을 제공하는데, 몇 달 혹은 1년 이상 아무도 사용하지 않는 인덱스가 있다면 과감하게 삭제하여 시스템 자원을 확보하고 쓰기 성능을 높여야한다.