
## 개요

- **개념적 모델링(ERD)** → 데이터 구조 설계
- **논리적 모델링** → 정규화, 중복 제거
- **물리적 모델링(Physical Modeling)** → DBMS(MySQL, Oracle 등)에 최적화된 실제 구조로 구현
- 초점: **성능**, **저장 효율성**, **DBMS 특성 반영**

## 논리적 모델링 vs 물리적 모델링 비교

| 측면    | 논리적 모델링    | 물리적 모델링              |
| ----- | ---------- | -------------------- |
| DBMS  | 독립적        | 종속적                  |
| 목적    | 데이터 구조 정의  | DBMS 최적화 구현          |
| 주요 작업 | 정규화, 관계 정의 | 인덱스, 파티션, 성능 튜닝      |
| 고려 요소 | 무결성, 중복 최소 | 하드웨어, 쿼리 패턴          |
| 산출물   | ERD, 용어사전  | DDL, 테이블 정의서, 인덱스 설계 |
## 물리적 모델링 프로세스

1. 테이블과 컬럼 변환 (Naming Convention 적용)
2. 데이터 타입 정의 (`VARCHAR`, `INT`, `DATETIME` 등)
3. 제약조건 설정 (PK, FK, `NOT NULL`, `UNIQUE`)
4. 인덱스 설계
5. 역정규화(필요 시)
6. 파티셔닝/샤딩
7. 뷰, 프로시저, 트리거 설계

## 명명 규칙 (Naming Convention)

### 기본 원칙

1. 영어 사용
2. **소문자 + 스네이크 케이스** (`member_id`, `created_at`)
3. 명확하고 서술적인 이름 (`member` O - `mem` X)
4. `is_`, `has_` 등 Boolean 접두사
5. 컬럼은 단수 명사 사용
6. 의미 있는 축약어만 사용 (`member_id`, `qty`)
7. 단위 명시 (`price_krw`, `weight_kg`)
8. 일관성 유지가 최우선

## 축약어와 단수/복수 규칙

### 좋은 축약어의 조건

- 보편성 (`id`, `avg`, `qty`)
- 비모호성 (`desc`, `auth` 피하기)
- `descripts`를 `desc`로 축약하면 내림차순 예약어와 혼동
- 일관성 및 문서화 필수


### 테이블 이름

- 단수형: 엔티티 개념 명확 (`member`)
- 복수형: 집합 의미 (`members`)
- 한국 실무에서는 **단수형**을 주로 사용

## 데이터 타입 가이드

### 문자형

- `VARCHAR(M)` : 가변 길이, 가장 일반적
- `CHAR(M)` : 고정 길이
- `TEXT` : 긴 문자열 (게시글 본문 등)

- **실무 팁:** 대부분의 경우 `VARCHAR`가 가장 합리적인 선택이다.

### 숫자형

| 타입             | 용도         | 비고       |
| -------------- | ---------- | -------- |
| `TINYINT`      | 상태 코드      | 1 byte   |
| `INT`          | 일반 ID      | 4 byte   |
| `BIGINT`       | 대량 데이터용 PK | 8 byte   |
| `DECIMAL(M,D)` | 금액, 정확한 계산 | 고정 소수점   |
| `DOUBLE`       | 근사 계산용     | 소수 오차 가능 |
**권장:** 핵심 테이블의 PK는 `BIGINT`로 통일 (확장성과 일관성 확보)

### 날짜/시간형

- `DATE` : 날짜만
- `DATETIME` : 날짜 + 시간
- `TIME` : 시간만

**기본 컬럼**
- `created_at`: 생성 시점
- `updated_at`: 수정 시점
- 예외로 `ordered_at`같이 비즈니스 이벤트가 발생한 논리적인 시간을 기록하는 용도의 컬럼을 추가하면 더 정교하게 관리할 수 있음
- 3시에 오픈하여 선착순으로 진행하는 이벤트가 있다고 쳤을 때 고객이 들어와서 비즈니스 로직을 처리하고 데이터베이스에 저장되는 일련의 시간 차가 있을 수 있으니 이를 더욱 정교하게 관리하는 방식

#### 자동화 예시
```sql
created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
```

## 역정규화 (Denormalization)

- 정규화의 원칙을 의도적으로 깨는 설계
- 목적: **조회 성능 향상**
- 중복 데이터 허용으로 JOIN 최소화
- 과도한 역정규화는 데이터 무결성 저하 유의

## 용어 사전 (Terminology Dictionary)

|분류|한글명|영문|예시|
|---|---|---|---|
|날짜/시간|생성일시|created_at|`created_at`|
|날짜/시간|수정일시|updated_at|`updated_at`|
|상태|활성 여부|is_active|`is_active`|
|수량|수량|qty|`qty`|
## 실무 요약

- PK는 **BIGINT로 통일**
- 모든 테이블에 `created_at`, `updated_at` 추가
- 컬럼은 **단수**, 테이블은 **단수(한국 기준)**
- 일관된 Naming Rule과 용어사전 관리
- 역정규화는 **성능 최적화의 최후 수단**