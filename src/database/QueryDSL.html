
### QueryDSL 이란?

- 쿼리를 Java로 `type-safe` 하게 개발할 수 있게 지원하는 프레임워크
- `Type-safe`의 기능
- 컴파일 시 에러 체크
- Code-assistant
- 주로 JPA 쿼리(JPQL)에 사용

### QueryDSL 을 사용하기에 앞서

```java
질문 : 사람을 찾아보자

- 20 ~ 40살
- 성 = 김씨
- 나이 많은 순서
- 3명을 출력하라.


1. JPQL(HQL)

public void jpql() {
String query = "select m from Member m where m.age between 20 and 40 and m.name like '김%' order by m.age desc";
}

List<Member> resultList = entityManager.createQuery(query, Member.class)
  .setMaxResults(3).getResultList();

  2. Criteria API

  public void jpaCriteriaQuery() {
  CriteriaBuilder cb = entityManager.getCriteriaBuilder();
  CriteriaQuery<Member> cq = cb.createQuery(Member.class);
    Root<Member> root = cq.from(Member.class);

      Path<Integer> age = root.get("age");
        Predicate between = cb.between(age,20,40);

        Path<String> path = root.get("name);
          Predicate like = cb.lie(path, "%김");

          CriteriaQuery<Member> query = cq.where(cb.and(between, like));
            query.orderBy(cb.desc(age));

            List<Member> resultList = entityManager.createQuery(query).setMaxResults(3).getResultList();
              }

              3. MetaModel Criteria API (type-safe)
              root.get("age") -> root.get(Member_.age);
              ...
              ```

              1. JPQL(HQL)
              - 장점 : 네이티브 쿼리와 비슷해서 금방 익숙해짐
              - 단점 : `Type-safe`가 아니며 동적쿼리 생성이 어려움

              2. Criteria API
              - 장점 : 동적 쿼리 생성이 쉬움(?, 가시성이 좋지 않고 오히려 더 길고 어려운 것 같음)
              - 단점 : `Type-safe`가 아니며 너무 복잡하고 사용하기에 앞서 알아야 할게 많음

              3. MetaModel Criteria API (type-safe)
              - CriteriaAPI + MetaModel
              - Criteria API 와 거의 동일
              - `Type-safe 지원`
              - 복잡하긴 마찬가치


              ### QueryDSL 분석

              - Domain (도메인)
              - Specific (특화)
              - Language (언어)
              #### DSL

              - 도메인 + 특화 + 언어
              - 특정한 도메인에 초점을 맞춘 제한적인 표현력을 가진 컴퓨터 프로그래밍 언어
              - 특징 : 단순, 간결, 유창

              #### QueryDSL

              - 쿼리 + 도메인 + 특화 + 언어
              - 쿼리에 특화된 프로그래밍 언어
              - 특징 : 단순, 간결, 유창
              - 다양한 저장소 쿼리 기능 통합
              - JPA, MongoDB, SQL 같은 기술들을 위해 `type-safe SQL`을 만드는 프레임워크

              ### QueryDSL-JPA 를 사용하면?

              - QueryDSL-JPA 라는 모듈을 사용한다고 가정
              - Member 객체가 있고, `@Entity`를 통해 JPA 에서 자동으로 테이블을 생성해준다고 가정
              - Member.java(`@Entity`) -> APT(`AnnotationProcessTool) -> `QMember.java` 생성
              ```java
              public class QMember {
              public final NumberPath<Long> id = createNumber("id", Long.class);
                public final NumberPath<Integer> age = createNumber("age", Integer.class);
                  public final StringPath name = createString("name");

                  public static final QMember member = new Qmember("member");
                  }
                  ```
                  - 위 와 같은 객체를 자동으로 생성해주며 아래와 같이 사용된다.

                  ```java
                  JPAQueryFactory query = new JPAQueryFactory(entityManager);
                  QMmeber m = QMember.member;

                  List<Member> list = query
                    .select(m)
                    .from(m)
                    .where(m.age.between(20,40).and(m.name.like("김%"))
                    .orderBy(m.age.desc())
                    .limit(3)
                    .fetch(m);
                    ```

                    1. Querydsl-JPA
                    - Querydsl-JPA 은 JPQL을 빌더처럼 사용 할 수 있게 도와주는 모듈
                    - 장점
                    - `type-safe`
                    - 단순함
                    - 쉬움
                    - 단점
                    - Q코드 생성을 위한 APT 설정을 해줘야 함

                    ### QueryDSL 구성

                    - Query
                    - ex) from, where, join
                    - Path
                    - ex) QMember, Qmember.name
                    - Expression
                    - ex) name.eq, name.gt
                    - 기능
                    - from
                    - innerJoin, join, leftJoin, fullJoin, on
                    - where (and, or, allOf, anyOf)
                    - group By
                    - having
                    - orderBy (desc, asc)
                    - limit, offset, restrict(limit + offset) (Paging)
                    - list
                    - iterate
                    - count
                    - fetch() : 목록 조회
                    - fetchOne() : 단건 조회

                    ### QueryDSL 동적 쿼리

                    ```java
                    String firstName = "김%";
                    int min = 20, max = 40;

                    BooleanBuilder builder = new BooleanBuilder();

                    if(StringUtils.hasText(str))
                    builder.and(m.name.startWith(firstName));

                    if(min != 0 && max != 0)
                    builder.and(m.age.between(min, max));

                    List<Member> results = query
                      .select(m)
                      .from(m)
                      .where(builder)
                      .fetch(m);
                      ```

                      ### QueryDSL 조인 쿼리

                      ```java
                      QMember m = QMember.member;
                      QMemberCard mc = QMemberCard.memberCard;

                      List<Member> list = query
                        .select(m)
                        .from(m)
                        .join(m.memberCards, mc)
                        .fetch(m);
                        ```

                        ### QueryDSL 페이징, 정렬

                        ```java
                        List<Member> result = queryFactory
                          .selectFrom(member)
                          .orderBy(member.username.desc())
                          .offset(1) // 0부터 시작 (zero index)
                          .limit(2) // 최대 2건 조회
                          .fetch();
                          ```

                          ### QueryDSL 초기 설정

                          ```java
                          //Querydsl 추가 (스프링 부트 3.x 버전 설정법)
                          implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
                          annotationProcessor "com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jakarta" annotationProcessor "jakarta.annotation:jakarta.annotation-api" annotationProcessor "jakarta.persistence:jakarta.persistence-api"
                          ```

                          ```java
                          //Querydsl 추가, 자동 생성된 Q클래스 gradle clean으로 제거 (gradle 맨 밑 추가)
                          clean {
                          delete file('src/main/generated')
                          }
                          ```

                          - 그 외 Q 클래스를 생성해줘야 하는데, 빌드 방식이 인텔리제이 인 경우 `Ctl + F9`를 통하여 빌드를 해서 Q 클래스를 생성하거나, Application 을 한 번 구동시키면 자동으로 생성된다.
                          - Gradle 빌드 방식이라면, gradle 설정을 열어 `build` 에서 `clean` 을 한 번 한 뒤, `other` 에서 `compileJava`를 실행하면 된다.
                          - 인텔리제이 방식의 빌드에선 `main` 패키지 쪽에 `generated` 디렉터리가 생성되기 때문에 버전 관리 시 `/src/main/generated`를 커스텀 하면 된다.
                          ### QueryDSL 공통

                          - QueryDSL 을 사용하려면 `JPAQueryFactory` 객체가 필요하다. `JPAQueryFactory`는 JPA 쿼리인 JPQL 을 만들기 때문에 `EntityManager`객체가 필요하다.
                          - 설정 방식은 `JdbcTemplate`을 설정하는 것과 유사하다.
                          - 참고로 `JPAQueryFactory`를 스프링 빈으로 등록해서 사용해도 된다.
                          ### QueryDSL 결론

                          - `type-safe`지원 (컴파일 에러, `Ctl+space`,`Code-assistant`)
                          - 그러나 QueryDSL은 JPQL 문법이 기반으로 되어 있기에 JPQL 로 해결하기 어려운 복잡한 쿼리는 네이티브 SQL 쿼리 사용 (`JdbcTemplate`, `MyBatis`)

                          ---

                          ### 기본 Q-Type 활용

                          - Q클래스 인스턴스를 사용하는 2가지 방법
                          ```java
                          QMember member = new QMember("m"); // 별칭 직접 지정
                          QMember member = QMember.member; // 기본 인스턴스 사용
                          ```

                          ### 검색 조건 쿼리

                          - JPQL이 제공하는 모든 검색 조건 제공
                          ```java
                          member.username.eq("member1") // username = 'member1'
                          member.username.ne("member1") // username != 'member1'
                          member.username.eq("member1").not() // username != 'member1'

                          member.username.isNotNull() // 이름이 is not null

                          member.age.in(10,20) // age in (10,20)
                          member.age.notIn(10,20) // age not in (10,20)
                          member.age.between(10,30) // between 10, 30

                          member.age.goe(30) // age >= 30
                          member.age.gt(30) // age > 30
                          member.age.loe(30) // age <= 30
                          member.age.lt(30) // age < 30

                          member.username.like("member%") // like 검색
                          member.username.contains("member") // like '%member%' 검색
                          member.username.startWith("member") // like 'member%' 검색
                          ```

                          - `and`방식의 다른 표현 방법
                          ```java
                          // 기존 'and' 표현 방식
                          Member findMember = query
                          .selectFrom(member)
                          .where(member.username.eq("member1")
                          .and(member.age.goe(10))
                          )
                          .fetchOne();

                          // 다른 'and' 표현 방식 (쉼표로 나누는 방식은 'and'만 가능)
                          Member findMember = query
                          .selectFrom(member)
                          .where(
                          member.username.eq("member1"),
                          // 참조를 통해 'and'를 호출하지 않아도 쉼표로 처리할 수 있음
                          member.age.eq(10)
                          )
                          .fetchOne();
                          ```

                          ### 결과 조회

                          - `fetch()` : 리스트 조회, 데이터 없으면 빈 리스트 반환
                          - `fetchOne()` : 단 건 조회
                          - 결과 없으면 `null`
                          - 결과가 둘 이상이면 `NonUniqueResultException`
                          - `fetchFirst()` : `limit(1).fetchOne()`
                          - `fetchResults()` : 페이징 정보 포함, total count 쿼리 추가 실행, 사용 X
                          - `fetchCount` : count 쿼리로 변경해서 count 수 조회, 사용 X (현재는 아래와 같은 방식을 사용)
                          - `select(Wildcard.count)` // **select count(*)**
                          - `select(member.count())` // **select count(member.id)**
                          - 응답 결과가 숫자 하나이므로 `fetchOne()`을 사용
                          - 혹은 `count`쿼리만 가져올 땐 `PageableExecutionUtils.getPage` 사용하여 최적화

                          ### 정렬

                          ```java
                          void sort() {
                          em.persist(createMember(null, 100, null));
                          em.persist(createMember("member5", 100, null));
                          em.persist(createMember("member6", 100, null));

                          List<Member> result = query
                            .selectFrom(member)
                            .where(member.age.eq(100))
                            .orderBy(member.age.desc(),
                            member.username.asc().nullsLast())
                            .fetch();

                            Member member5 = result.get(0);
                            Member member6 = result.get(1);
                            Member memberNull = result.get(2);
                            assertThat(member5.getUsername()).isEqualTo("member5");
                            assertThat(member6.getUsername()).isEqualTo("member6");
                            assertThat(memberNull.getUsername()).isNull();
                            ```

                            - 자바의 객체 참조를 통하여 SQL 의 정렬처럼 사용할 수 있음

                            ### 페이징

                            ```java
                            @Test
                            void paging1() {
                            List<Member> result = query
                              .selectFrom(member)
                              .orderBy(member.username.desc())
                              .offset(1)
                              .limit(2)
                              .fetch();

                              assertThat(result).hasSize(2);
                              assertThat(result.getFirst().getUsername()).isEqualTo("member3");
                              }

                              ...

                              public Page<MemberTeamDto> searchPageComplex(MemberSearchCondition condition, Pageable pageable) {
                                List<MemberTeamDto> content = query
                                  .select(new QMemberTeamDto(
                                  member.id.as("memberId"),
                                  member.username,
                                  member.age,
                                  team.id.as("teamId"),
                                  team.name
                                  ))
                                  .from(member)
                                  .leftJoin(member.team, team)
                                  .where(
                                  usernameEq(condition.getUsername()),
                                  teamNameEq(condition.getTeamName()),
                                  ageGoe(condition.getAgeGoe()),
                                  ageLoe(condition.getAgeLoe())
                                  )
                                  .offset(pageable.getOffset())
                                  .limit(pageable.getPageSize())
                                  .fetch();

                                  JPAQuery<Long> countQuery = query
                                    .select(member.count())
                                    .from(member)
                                    .leftJoin(member.team, team)
                                    .where(
                                    usernameEq(condition.getUsername()),
                                    teamNameEq(condition.getTeamName()),
                                    ageGoe(condition.getAgeGoe()),
                                    ageLoe(condition.getAgeLoe())
                                    );

                                    return PageableExecutionUtils.getPage(content, pageable, countQuery::fetchOne);
                                    }
                                    ```

                                    - `offset`,`limit`를 통해 자바 코드로 표현할 수 있음

                                    ### 집계 함수

                                    ```java
                                    void aggregation() {
                                    List<Tuple> result = query
                                      .select(
                                      member.count(),
                                      member.age.sum(),
                                      member.age.avg(),
                                      member.age.max(),
                                      member.age.min()
                                      )
                                      .from(member)
                                      .fetch();

                                      Tuple tuple = result.get(0);
                                      assertThat(tuple.get(member.count())).isEqualTo(4);
                                      assertThat(tuple.get(member.age.sum())).isEqualTo(100);
                                      assertThat(tuple.get(member.age.avg())).isEqualTo(25);
                                      assertThat(tuple.get(member.age.max())).isEqualTo(40);
                                      assertThat(tuple.get(member.age.min())).isEqualTo(10);
                                      }

                                      ...

                                      void groupBy() {
                                      List<Tuple> result = query
                                        .select(team.name, member.age.avg())
                                        .from(member)
                                        .join(member.team, team)
                                        .groupBy(team.name)
                                        .fetch();

                                        Tuple teamA = result.get(0);
                                        Tuple teamB = result.get(1);

                                        assertThat(teamA.get(team.name)).isEqualTo("teamA");
                                        assertThat(teamA.get(member.age.avg())).isEqualTo(15);

                                        assertThat(teamB.get(team.name)).isEqualTo("teamB");
                                        assertThat(teamB.get(member.age.avg())).isEqualTo(35);
                                        }

                                        ...

                                        // Having 절 역시 사용 가능
                                        query
                                        .select(item.price.avg())
                                        .from(item)
                                        .groupBy(item.price)
                                        .having(item.price.goe(10000))
                                        .fetch();

                                        ```


                                        ### 조인

                                        - 기본 조인
                                        - 조인의 기본 문법은 첫 번째 파라미터에 조인 대상을 지정하고, 두 번째 파라미터에 별칭으로 사용할 Q 타입을 지정하면 된다.
                                        - `join(조인 대상, 별칭으로 사용할 Q타입)`
                                        - ex) `join(Member.member.team, Team.team)`
                                        ```java
                                        void join() {
                                        List<Member> result = query
                                          .selectFrom(member)
                                          .leftJoin(member.team, team)
                                          .where(team.name.eq("teamA"))
                                          .fetch();

                                          assertThat(result).extracting("username").containsExactly("member1", "member2");
                                          ```

                                          - 세타 조인
                                          ```java
                                          void theta_join() {
                                          em.persist(createMember("teamA", 0, null));
                                          em.persist(createMember("teamB", 0, null));

                                          List<Member> result = query
                                            .select(member)
                                            .from(member, team) // 인라인에 테이블 둘 다 나열
                                            .where(member.username.eq(team.name))
                                            .fetch();

                                            assertThat(result)
                                            .extracting("username")
                                            .containsExactly("teamA", "teamB");
                                            }
                                            ```

                                            ### 조인 - on절

                                            - ON절을 활용한 조인
                                            1. 조인 대상 필터링
                                            2. 연관관계 없는 엔티티 외부 조인

                                            #### 조인 대상 필터링

                                            ```java
                                            /**
                                            * 예) 회원과 팀을 조인하면서, 팀 이름이 teamA인 팀만 조인, 회원은 모두 조회
                                            * JPQL : select m, t from Member m left join m.team t where t.name = 'teamA'
                                            */@Test
                                            void join_on_filtering() {
                                            List<Tuple> result = query
                                              .select(member, team)
                                              .from(member)
                                              .leftJoin(member.team, team)
                                              .on(team.name.eq("teamA"))
                                              .fetch();

                                              for (Tuple tuple : result) {
                                              System.out.println("tuple = " + tuple);
                                              }
                                              }
                                              ```

                                              - 참고로 `on`절을 활용해 조인 대상을 필터링 할 때, 외부 조인이 아니라 내부 조인을 사용하면, where 절에서 필터링 하는 것과 기능이 동일하다. 따라서 `on`절을 활용한 조인 대상 필터링을 사용할 때, 내부 조인 이면 익숙한 where 절로 해결하고, 정말 외부조인이 필요한 경우에만 이 기능을 사용하는게 좋다.
                                              ```java
                                              @Test
                                              void join_on_filtering() {
                                              List<Tuple> result = query
                                                .select(member, team)
                                                .from(member)
                                                //                .leftJoin(member.team, team)
                                                //                .on(team.name.eq("teamA"))
                                                .join(member.team, team)
                                                .where(team.name.eq("teamA"))
                                                // 이 방식과 leftJoin.on 절의 방식의 결과가 동일하다.
                                                .fetch();
                                                ```


                                                #### 연관관계 없는 엔티티 외부 조인

                                                ```java
                                                /**
                                                * 연관관계 없는 엔티티 외부 조인
                                                * 회원의 이름이 팀 이름과 같은 대상을 외부 조인
                                                */
                                                @Test
                                                void join_on_no_relation() {
                                                em.persist(createMember("teamA", 0, null));
                                                em.persist(createMember("teamB", 0, null));

                                                List<Tuple> result = query
                                                  .select(member.username, team.name)
                                                  .from(member)
                                                  .leftJoin(team)
                                                  .on(member.username.eq(team.name))
                                                  .fetch();

                                                  for (Tuple tuple : result) {
                                                  System.out.println("tuple = " + tuple);
                                                  }
                                                  }
                                                  ```

                                                  - 이렇게만 보면 감이 잘 안 올텐데, 이건 JPA 연관관계 없이도 조인이 가능하도록 해준다.
                                                  - 쉽게 생각하면, `Member` 테이블과 `Review` 테이블처럼 서로 연관관계(`@ManyToOne`, `@OneToMany` 등)가 맺어져 있지 않은 상태에서는 **JPA의 객체 그래프 탐색으로는 조인할 수 없다**.
                                                  - 이런 경우 두 테이블 간에 특정 컬럼(예: `username`)을 기준으로 조인이 필요할 때, **연관관계 없는 엔티티 외부 조인** 방식을 사용해 `QueryDSL`에서 직접 `on` 절을 통해 조인 조건을 지정해 조인을 수행할 수 있다.
                                                  ```java
                                                  List<Tuple> result = query
                                                    .select(member.username, review.username)
                                                    .from(member)
                                                    .leftJoin(review)
                                                    .on(member.username.eq(review.username))
                                                    .fetch();
                                                    ```

                                                    ### 조인 - 패치 조인

                                                    - 패치 조인은 SQL 에서 제공하는 기능은 아니다. SQL 조인을 활용해서 연관된 엔티티를 SQL 한 번에 조회하는 기능이다. 주로 성능 최적화에 사용하는 방법이다.

                                                    ```java
                                                    @PersistenceUnit
                                                    EntityManagerFactory emf;

                                                    @Test
                                                    void fetchJoinNo() {
                                                    em.flush();
                                                    em.clear();

                                                    Member findMember = query
                                                    .selectFrom(member)
                                                    .where(member.username.eq("member1"))
                                                    .fetchOne();

                                                    boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());

                                                    assertThat(loaded).as("패치 조인 미적용").isFalse();
                                                    }

                                                    @Test
                                                    void fetchJoinUse() {
                                                    em.flush();
                                                    em.clear();

                                                    Member findMember = query
                                                    .selectFrom(member)
                                                    .join(member.team, team).fetchJoin()
                                                    .where(member.username.eq("member1"))
                                                    .fetchOne();

                                                    boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam());

                                                    assertThat(loaded).as("패치 조인 미적용").isTrue();
                                                    }
                                                    ```
                                                    - `JPQL` 에서 `join fetch`를 작성해줘야 하던 부분을 `.fetchJoin` 한 방으로 처리할 수 있다.

                                                    ### 서브 쿼리

                                                    - `com.querydsl.jpa.JPAExpressions` 사용

                                                    ```java
                                                    /**
                                                    * 나이가 가장 많은 회원 조회
                                                    */
                                                    @Test
                                                    void subQuery() {
                                                    QMember memberSub = new QMember("memberSub");

                                                    List<Member> result = query
                                                      .selectFrom(member)
                                                      .where(member.age.eq(
                                                      JPAExpressions.select(memberSub.age.max())
                                                      .from(memberSub)
                                                      ))
                                                      .fetch();

                                                      assertThat(result).extracting("age").containsExactly(40);
                                                      }

                                                      /**
                                                      * 나이가 평균 이상인 회원 조회
                                                      */
                                                      @Test
                                                      void subQueryGoe() {
                                                      QMember memberSub = new QMember("memberSub");

                                                      List<Member> result = query
                                                        .selectFrom(member)
                                                        .where(member.age.goe(
                                                        JPAExpressions.select(memberSub.age.avg())
                                                        .from(memberSub)
                                                        ))
                                                        .fetch();

                                                        assertThat(result).extracting("age").containsExactly(30, 40);
                                                        }

                                                        /**
                                                        * 나이가 평균 이상인 회원 조회 (In 절)
                                                        */@Test
                                                        void subQueryIn() {
                                                        QMember memberSub = new QMember("memberSub");

                                                        List<Member> result = query
                                                          .selectFrom(member)
                                                          .where(member.age.in(
                                                          JPAExpressions.select(memberSub.age)
                                                          .from(memberSub)
                                                          .where(memberSub.age.gt(10))
                                                          ))
                                                          .fetch();

                                                          assertThat(result).extracting("age").containsExactly(20, 30, 40);
                                                          }

                                                          /**
                                                          * 나이가 평균 이상인 회원 조회 (스칼라)
                                                          */@Test
                                                          void selectSubQuery() {
                                                          QMember memberSub = new QMember("memberSub");

                                                          List<Tuple> result = query
                                                            .select(member.username,
                                                            // JPAExpressions 는 Static Import 사용 가능
                                                            JPAExpressions.select(memberSub.age.avg())
                                                            .from(memberSub))
                                                            .from(member)
                                                            .fetch();

                                                            for (Tuple tuple : result) {
                                                            System.out.println("tuple = " + tuple);
                                                            }
                                                            }
                                                            ```

                                                            - `from`절의 서브 쿼리 한계
                                                            - JPA JPQL 서브쿼리의 한계점으로 `from`절의 서브쿼리(인라인 뷰)는 지원하지 않는다.
                                                            - QueryDSL 도 결국에는 JPQL 을 만들어내는거라 JPQL 에서 인라인 뷰 서브쿼리를 지원하지 않기에 이 부분 역시 한계점이 명확하다.
                                                            - 하이버네이트 구현체를 사용하면 `select` 절의 서브 쿼리는 지원한다. QueryDSL 역시 하이버네이트 구현체를 사용하면 `select`절의 서브쿼리를 지원한다.
                                                            - `from`절의 서브쿼리 해결방안
                                                            1. 서브 쿼리를 `join`으로 변경한다. (가능한 상황도 있고, 불가능한 상황도 있음)
                                                            2. 애플리케이션에서 쿼리를 2번으로 분리하여 실행한다.
                                                            3. 네이티브 쿼리를 사용한다.

                                                            ### Case

                                                            ```java
                                                            @Test
                                                            void basicCase() {
                                                            List<String> result = query
                                                              .select(member.age
                                                              .when(10).then(Expressions.constant("열살"))
                                                              .when(20).then(Expressions.constant("스무살"))
                                                              .otherwise(Expressions.constant("기타")))
                                                              .from(member)
                                                              .fetch();

                                                              assertThat(result.getFirst()).isEqualTo("열살");
                                                              }

                                                              @Test
                                                              void complexCase() {
                                                              List<String> result = query
                                                                .select(new CaseBuilder()
                                                                .when(member.age.between(0, 20)).then(Expressions.constant("0~20살"))
                                                                .when(member.age.between(21, 30)).then(Expressions.constant("21~30살"))
                                                                .otherwise(Expressions.constant("기타"))
                                                                )
                                                                .from(member)
                                                                .fetch();

                                                                for (String s : result) {
                                                                System.out.println("s = " + s);
                                                                }
                                                                }
                                                                ```

                                                                - `Case` 문은 가급적이면 사용 X, 프레젠테이션 레이어 단계에서 해결해야 베스트 프랙티스

                                                                ### 상수, 문자 더하기

                                                                ```java
                                                                // 상수가 필요할 때 `Expressions.constant(xxx)` 사용
                                                                @Test
                                                                void constant() {
                                                                List<Tuple> result = query
                                                                  .select(member.username, Expressions.constant("A"))
                                                                  .from(member)
                                                                  .fetch();

                                                                  for (Tuple tuple : result) {
                                                                  System.out.println("tuple = " + tuple);
                                                                  }
                                                                  }

                                                                  // 문자 더하기 concat
                                                                  @Test
                                                                  void concat() {
                                                                  List<String> result = query
                                                                    .select(member.username.concat("_").concat(member.age.stringValue()))
                                                                    .from(member)
                                                                    .where(member.username.eq("member1"))
                                                                    .fetch();

                                                                    for (String s : result) {
                                                                    System.out.println("s = " + s);
                                                                    }
                                                                    }
                                                                    ```

                                                                    - `member.age.stringValue()`부분이 중요한데, 문자가 아닌 다른 타입들을 `stringValue()`를 통해 문자로 변환할 수 있다. 이 방법은 `ENUM`을 처리할 때도 자주 사용한다.

                                                                    ### 프로젝션과 결과 반환 - 기본

                                                                    ```java
                                                                    @Test
                                                                    void simpleProjection() {
                                                                    List<String> result = query
                                                                      .select(member.username)
                                                                      .from(member)
                                                                      .fetch();

                                                                      for (String s : result) {
                                                                      System.out.println("s = " + s);
                                                                      }
                                                                      }

                                                                      @Test
                                                                      void tupleProjection() {
                                                                      List<Tuple> result = query
                                                                        .select(member.username, member.age)
                                                                        .from(member)
                                                                        .fetch();

                                                                        for (Tuple tuple : result) {
                                                                        String username = tuple.get(member.username);
                                                                        Integer age = tuple.get(member.age);
                                                                        System.out.println("username = " + username);
                                                                        System.out.println("age = " + age);
                                                                        }
                                                                        }
                                                                        ```

                                                                        - 기본적인 프로젝션 방식으로 `select`절에 단일 필드 및, 다중 필드들이 들어가있을 때 단일 필드일 경우 필드에 맞는 반환 타입이 응답되고, 다중 필드의 경우 `QueryDSL`에서 지원하는 `Tuple`객체가 반환 타입이 되면서 여러가지 반환 타입을 받을 수 있다.

                                                                        ### 프로젝션 결과 반환 - DTO 조회

                                                                        - 일단 기본적인 JPA 에서 `new operation` 방식으로 조회 시
                                                                        ```java
                                                                        List<MemberDto> result = em.createQuery("select new study.querydsl.dto.MemberDto(m.username, m.age) from Member m", MemberDto.class)
                                                                          .getResultList();
                                                                          ```
                                                                          - 위 와 같이 DTO 패키지 경로를 다 명시해줘야하는 불편함과, `setter`같은 자바빈 프로퍼티 방식을 호환하지 않고, 생성자 방식만 지원한다는 부분에서 가시성 측면과 유지보수성이 좋지않다.

                                                                          - QueryDSL 빈 생성 (`Bean population`)
                                                                          - QueryDSL 에선 JPA 에서 사용하던 DTO 프로젝션 방식을 깔끔하게 해결할 수 있다.
                                                                          1. 프로퍼티 접근
                                                                          2. 필드 직접 접근
                                                                          3. 생성자 사용
                                                                          4. `@QueryProjection` 사용
                                                                          ```java
                                                                          // 프로퍼티 Setter 방법
                                                                          @Test
                                                                          void findDtoBySetter() {
                                                                          List<MemberDto> result = query
                                                                            .select(Projections.fields(MemberDto.class,
                                                                            member.username,
                                                                            member.age))
                                                                            .from(member)
                                                                            .fetch();

                                                                            for (MemberDto memberDto : result) {
                                                                            System.out.println("memberDto = " + memberDto);
                                                                            }
                                                                            }

                                                                            // 필드 접근 방법
                                                                            @Test
                                                                            void findDtoByField() {
                                                                            List<MemberDto> result = query
                                                                              .select(Projections.bean(MemberDto.class,
                                                                              member.username,
                                                                              member.age))
                                                                              .from(member)
                                                                              .fetch();

                                                                              for (MemberDto memberDto : result) {
                                                                              System.out.println("memberDto = " + memberDto);
                                                                              }
                                                                              }

                                                                              // 생성자 접근 방법
                                                                              @Test
                                                                              void findDtoByConstructor() {
                                                                              List<MemberDto> result = query
                                                                                .select(Projections.constructor(MemberDto.class,
                                                                                member.username,
                                                                                member.age))
                                                                                .from(member)
                                                                                .fetch();

                                                                                for (MemberDto memberDto : result) {
                                                                                System.out.println("memberDto = " + memberDto);
                                                                                }
                                                                                }
                                                                                ```

                                                                                - 예외적으로 `별칭`이 맞지 않는 상태에서 `Field`방식으로 주입 시에도 당연히 문제가 생긴다.
                                                                                ```java
                                                                                @Data
                                                                                @NoArgsConstructor
                                                                                public class UserDto {

                                                                                private String name;
                                                                                private int age;
                                                                                }

                                                                                ...

                                                                                @Test
                                                                                void findUserDto() {
                                                                                List<UserDto> result = query
                                                                                  .select(Projections.fields(UserDto.class,
                                                                                  member.username.as("name"), // as가 없으면 `null`로 출력
                                                                                  member.age))
                                                                                  .from(member)
                                                                                  .fetch();

                                                                                  for (UserDto userDto : result) {
                                                                                  System.out.println("userDto = " + userDto);
                                                                                  }
                                                                                  }
                                                                                  ```

                                                                                  - 위 와 같이 프로퍼티나, 필드 직접 접근 시 필드명이 일치하지 않다면 `null`값이 들어가며, 이 경우에는 `.as`를 통해 별칭을 지칭해줘야한다.
                                                                                  - 서브 쿼리 내에서 별칭을 사용해야 할 땐 아래와 같이 `ExpressionUtils.as`를 사용하여 별칭을 지칭해줘야한다.
                                                                                  ```java
                                                                                  @Test
                                                                                  void findUserSubDto() {
                                                                                  QMember memberSub = new QMember("memberSub");

                                                                                  List<UserDto> result = query
                                                                                    .select(Projections.fields(UserDto.class,
                                                                                    member.username.as("name"),
                                                                                    ExpressionUtils.as(JPAExpressions
                                                                                    .select(memberSub.age.max())
                                                                                    .from(memberSub), "age")
                                                                                    ))
                                                                                    .from(member)
                                                                                    .fetch();

                                                                                    for (UserDto userDto : result) {
                                                                                    System.out.println("userDto = " + userDto);
                                                                                    }
                                                                                    }
                                                                                    ```

                                                                                    ```java
                                                                                    public class MemberDto() {
                                                                                    @QueryProjection
                                                                                    public MemberDto(String username, int age) {
                                                                                    this.username = username;
                                                                                    this.age = age;
                                                                                    }
                                                                                    }
                                                                                    ...

                                                                                    @Test
                                                                                    void findDtoByQueryProjection() {
                                                                                    List<MemberDto> result = query
                                                                                      .select(new QMemberDto(member.username, member.age))
                                                                                      .from(member)
                                                                                      .fetch();

                                                                                      for (MemberDto memberDto : result) {
                                                                                      System.out.println("memberDto = " + memberDto);
                                                                                      }
                                                                                      }
                                                                                      ```

                                                                                      - `@QueryProjection` 어노테이션은 `QueryDSL`라이브러리에서 지원하는 어노테이션이다.
                                                                                      - 이 어노테이션을 사용하면 타입 세이프의 도움을 받을 수 있어서 여러모로 유용하긴하나, 크게 단점을 뽑아보자면 일단 `Q`클래스 객체를 생성해야하는 부분, 그리고 `Dto`객체가 `QueryDSL`라이브러리에 의존적이게 된다는 부분인데 `Dto`객체 특성 상 프레젠테이션 계층부터 퍼시스트 계층까지 전부 사용이되는 객체이기에 아키텍처를 설계할 때 조심해야 할 수 있다.
                                                                                      - 개발편의성을 대폭 올려주지만, 유지보수성 및 결합도 때문에 쉽게 아키텍처를 변경할 수 없다는 단점이 있지만 `Dto`에서 어노테이션만 제거해주면 다시 순수한 `Dto`객체로 돌아온다는 부분으로 봤을 때 현재 프로젝트 상태에서 트레이드 오프를 따지며 선택해야 할 문제로 보인다.

                                                                                      ## 동적 쿼리를 해결하는 두 가지 방식

                                                                                      1. `BooleanBuilder`
                                                                                      2. `Where 다중 파라미터 사용`
                                                                                      ### 동적 쿼리 - BooleanBuilder

                                                                                      ```java
                                                                                      @Test
                                                                                      void dynamicQuery_BooleanBuilder() {
                                                                                      String usernameParam = "member1";
                                                                                      Integer ageParam = 10;

                                                                                      List<Member> result = searchMember1(usernameParam, ageParam);

                                                                                        assertThat(result).hasSize(1);
                                                                                        }

                                                                                        private List<Member> searchMember1(String usernameCond, Integer ageCond) {
                                                                                          BooleanBuilder builder = new BooleanBuilder(기본 값 조건 추가 가능);

                                                                                          if (usernameCond != null) {
                                                                                          builder.and(member.username.eq(usernameCond));
                                                                                          }

                                                                                          if (ageCond != null) {
                                                                                          builder.and(member.age.eq(ageCond));
                                                                                          }
                                                                                          return query
                                                                                          .selectFrom(member)
                                                                                          .where(builder)
                                                                                          .fetch();
                                                                                          }
                                                                                          ```

                                                                                          - `QueryDSL`은 동적 쿼리를 자바 코드로 간단하게 조립할 수 있다는게 강점이다.

                                                                                          ### 동적 쿼리 - Where 다중 파라미터 사용

                                                                                          ```java
                                                                                          private List<Member> searchMember2(String usernameCond, Integer ageCond) {
                                                                                            return query
                                                                                            .selectFrom(member)
                                                                                            .where(usernameEq(usernameCond), ageEq(ageCond))
                                                                                            //.where(allEq(usernameCond, ageCond))
                                                                                            .fetch();
                                                                                            }

                                                                                            private BooleanExpression usernameEq(String usernameCond) {
                                                                                            return usernameCond != null ? member.username.eq(usernameCond) : null;
                                                                                            }

                                                                                            private BooleanExpression ageEq(Integer ageCond) {
                                                                                            return ageCond != null ? member.age.eq(ageCond) : null;
                                                                                            }

                                                                                            private Predicate allEq(String usernameCond, Integer ageCond) {
                                                                                            return usernameEq(usernameCond).and(ageEq(ageCond));
                                                                                            }
                                                                                            ```

                                                                                            - `where` 조건에 `null`값은 무시되기 때문에 동적 쿼리를 사용할 수 있다.
                                                                                            - 메서드를 다른 쿼리에도 재사용 할 수 있다.
                                                                                            - 메서드 명으로 조건을 나누기에 가독성이 높아진다.
                                                                                            - 무엇보다 `allEq` 방식처럼 조합하여 사용할 수 있다 (`null`처리는 따로 해줘야 함)

                                                                                            ### 수정 삭제 벌크 연산

                                                                                            ```java
                                                                                            @Test
                                                                                            void bulkUpdate() {
                                                                                            // member1 = 10살 -> 비회원
                                                                                            // member1 = 20살 -> 비회원
                                                                                            // member1 = 30살 -> 유지
                                                                                            // member1 = 40살 -> 유지
                                                                                            long count = query
                                                                                            .update(member)
                                                                                            .set(member.username, "비회원")
                                                                                            .where(member.age.lt(28))
                                                                                            .execute();
                                                                                            }

                                                                                            @Test
                                                                                            void bulkAdd() {
                                                                                            long count = query
                                                                                            .update(member)
                                                                                            //                .set(member.age, member.age.add(1))
                                                                                            .set(member.age, member.age.multiply(1))
                                                                                            .execute();
                                                                                            }

                                                                                            @Test
                                                                                            void bulkDelete() {
                                                                                            query
                                                                                            .delete(member)
                                                                                            .where(member.age.goe(18))
                                                                                            .execute();
                                                                                            }
                                                                                            ```

                                                                                            - `QueryDSL`은 JPA처럼 영속성 컨텍스트를 사용하므로, 벌크 연산 후에는 `flush()` 및 `clear()`를 통해 컨텍스트를 초기화하지 않으면 DB와의 데이터 정합성이 깨질 수 있다. 이로 인해 장애가 발생할 수 있으니 주의가 필요하다.

                                                                                            ### SQL function 호출

                                                                                            ```java
                                                                                            @Test
                                                                                            void sqlFunction() {
                                                                                            List<String> result = query
                                                                                              .select(Expressions.stringTemplate(
                                                                                              "function('replace', {0}, {1}, {2})",
                                                                                              member.username, "member", "M")
                                                                                              )
                                                                                              .from(member)
                                                                                              .fetch();

                                                                                              for (String s : result) {
                                                                                              System.out.println("s = " + s);
                                                                                              }
                                                                                              }

                                                                                              @Test
                                                                                              void sqlFunction2() {
                                                                                              List<String> result = query
                                                                                                .select(member.username)
                                                                                                .from(member)
                                                                                                //                .where(member.username.eq(
                                                                                                //                        Expressions.stringTemplate(
                                                                                                //                                "function('lower', {0})",
                                                                                                //                                member.username))
                                                                                                //                )
                                                                                                .where(member.username.eq(member.username.lower()))
                                                                                                .fetch();

                                                                                                for (String s : result) {
                                                                                                System.out.println("s = " + s);
                                                                                                }
                                                                                                }
                                                                                                ```

                                                                                                - 기본적으로 ANSI 표준 함수들은 `QueryDSL`이 상당 부분 내장하고 있다.
                                                                                                - `lower`,`upper` 같은 함수들은 Expressions 객체를 사용 할 필요 없이, 바로 객체 참조를 통해 표준 메서드를 사용할 수 있다.
                                                                                                - 벤더마다 지원하는 함수들 이 외 다른 함수들을 사용하려면 직접 커스텀 함수를 만들어서 호출하면 되는데, 하이버네이트 6.0 이 전에는 하이버네이트 환경설정에 커스틈 함수를 만들어서 `dialect`환경설정에 등록하고 사용해줘야 했던 반면, 하이버네이트 6.0 이 후 부터는 `dialect`에 등록하지 않아도 사용자 함수를 바로 등록하여 사용할 수 있다.

                                                                                                ### QueryDSL Repository Supprot Custom

                                                                                                ```java
                                                                                                package study.querydsl.repository.support;

                                                                                                import com.querydsl.core.types.EntityPath;
                                                                                                import com.querydsl.core.types.Expression;
                                                                                                import com.querydsl.core.types.dsl.PathBuilder;
                                                                                                import com.querydsl.jpa.impl.JPAQuery;
                                                                                                import com.querydsl.jpa.impl.JPAQueryFactory;
                                                                                                import jakarta.annotation.PostConstruct;
                                                                                                import jakarta.persistence.EntityManager;
                                                                                                import org.springframework.beans.factory.annotation.Autowired;
                                                                                                import org.springframework.data.domain.Page;
                                                                                                import org.springframework.data.domain.Pageable;
                                                                                                import org.springframework.data.jpa.repository.support.JpaEntityInformation;
                                                                                                import org.springframework.data.jpa.repository.support.JpaEntityInformationSupport;
                                                                                                import org.springframework.data.jpa.repository.support.Querydsl;
                                                                                                import org.springframework.data.querydsl.SimpleEntityPathResolver;
                                                                                                import org.springframework.data.support.PageableExecutionUtils;
                                                                                                import org.springframework.stereotype.Repository;
                                                                                                import org.springframework.util.Assert;

                                                                                                import java.util.List;
                                                                                                import java.util.function.Function;

                                                                                                /**
                                                                                                * Querydsl 4.x 버전에 맞춘 Querydsl 지원 라이브러리
                                                                                                *
                                                                                                * @author Younghan Kim
                                                                                                * @see org.springframework.data.jpa.repository.support.QuerydslRepositorySupport
                                                                                                */@Repository
                                                                                                public abstract class Querydsl4RepositorySupport {

                                                                                                private final Class<?> domainClass;
                                                                                                private Querydsl querydsl;
                                                                                                private EntityManager entityManager;
                                                                                                private JPAQueryFactory queryFactory;

                                                                                                public Querydsl4RepositorySupport(Class<?> domainClass) {
                                                                                                Assert.notNull(domainClass, "Domain class must not be null!");
                                                                                                this.domainClass = domainClass;
                                                                                                }

                                                                                                @Autowired
                                                                                                public void setEntityManager(EntityManager entityManager) {
                                                                                                Assert.notNull(entityManager, "EntityManager must not be null!");
                                                                                                JpaEntityInformation<?, ?> entityInformation =
                                                                                                JpaEntityInformationSupport.getEntityInformation(domainClass, entityManager);
                                                                                                SimpleEntityPathResolver resolver = SimpleEntityPathResolver.INSTANCE;
                                                                                                EntityPath<?> path = resolver.createPath(entityInformation.getJavaType());
                                                                                                this.entityManager = entityManager;
                                                                                                this.querydsl = new Querydsl(entityManager, new PathBuilder<>(path.getType(), path.getMetadata()));
                                                                                                this.queryFactory = new JPAQueryFactory(entityManager);
                                                                                                }

                                                                                                @PostConstruct
                                                                                                public void validate() {
                                                                                                Assert.notNull(entityManager, "EntityManager must not be null!");
                                                                                                Assert.notNull(querydsl, "Querydsl must not be null!");
                                                                                                Assert.notNull(queryFactory, "QueryFactory must not be null!");
                                                                                                }

                                                                                                protected JPAQueryFactory getQueryFactory() {
                                                                                                return queryFactory;
                                                                                                }

                                                                                                protected Querydsl getQuerydsl() {
                                                                                                return querydsl;
                                                                                                }

                                                                                                protected EntityManager getEntityManager() {
                                                                                                return entityManager;
                                                                                                }

                                                                                                protected <T> JPAQuery<T> select(Expression<T> expr) {
                                                                                                  return getQueryFactory().select(expr);
                                                                                                  }

                                                                                                  protected <T> JPAQuery<T> selectFrom(EntityPath<T> from) {
                                                                                                    return getQueryFactory().selectFrom(from);
                                                                                                    }

                                                                                                    protected <T> Page<T> applyPagination(Pageable pageable,
                                                                                                      Function<JPAQueryFactory, JPAQuery<T>> contentQuery) {
                                                                                                        JPAQuery<T> jpaQuery = contentQuery.apply(getQueryFactory());
                                                                                                          List<T> content = getQuerydsl().applyPagination(pageable, jpaQuery).fetch();
                                                                                                            return PageableExecutionUtils.getPage(content, pageable, jpaQuery::fetchCount);
                                                                                                            }

                                                                                                            protected <T> Page<T> applyPagination(Pageable pageable,
                                                                                                              Function<JPAQueryFactory, JPAQuery<T>> contentQuery,
                                                                                                                Function<JPAQueryFactory, JPAQuery<Long>> countQuery) {
                                                                                                                  JPAQuery<T> jpaContentQuery = contentQuery.apply(getQueryFactory());
                                                                                                                    List<T> content = getQuerydsl().applyPagination(pageable, jpaContentQuery).fetch();
                                                                                                                      JPAQuery<Long> countResult = countQuery.apply(getQueryFactory());
                                                                                                                        return PageableExecutionUtils.getPage(content, pageable, countResult::fetchOne);
                                                                                                                        }
                                                                                                                        }
                                                                                                                        ```

                                                                                                                        - 선언형 프로그래밍을 통해 페이징과 정렬을 한 방 쿼리로 쉽게 만들 수 있다는 장점이 있음

                                                                                                                        ```java
                                                                                                                        public Page<Member> applyPaginationCountQuery(MemberSearchCondition condition, Pageable pageable) {
                                                                                                                          return applyPagination(pageable, contentQuery -> contentQuery
                                                                                                                          .selectFrom(member)
                                                                                                                          .leftJoin(member.team, team)
                                                                                                                          .where(
                                                                                                                          usernameEq(condition.getUsername()),
                                                                                                                          teamNameEq(condition.getTeamName()),
                                                                                                                          ageGoe(condition.getAgeGoe()),
                                                                                                                          ageLoe(condition.getAgeLoe())

                                                                                                                          ), countQuery -> countQuery
                                                                                                                          .select(member.count())
                                                                                                                          .leftJoin(member.team, team)
                                                                                                                          .where(
                                                                                                                          usernameEq(condition.getUsername()),
                                                                                                                          teamNameEq(condition.getTeamName()),
                                                                                                                          ageGoe(condition.getAgeGoe()),
                                                                                                                          ageLoe(condition.getAgeLoe())
                                                                                                                          )
                                                                                                                          );
                                                                                                                          }
                                                                                                                          ```