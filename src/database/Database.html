
## 데이터와 정보

### 1. 데이터(Data)
- **정의:** 가공되지 않은 개별 사실이나 값. 문맥이 없어 의미를 파악하기 어려움.
- **특징:**
- 의미 없는 기록 조각(날것, Raw)
- 예: `user01`, `티셔츠`, `25,000` (단독으로는 의미 불명)

---

### 1.5. 구조화된 데이터(Structured Data)
- **정의:** 각 데이터에 ‘꼬리표(Label)’를 붙여 의미를 부여한 형태.
- **예:**

| 주문번호 | 고객ID   | 상품명 | 수량  | 금액     | 날짜         |
| ---- | ------ | --- | --- | ------ | ---------- |
| 1001 | user01 | 티셔츠 | 2   | 50,000 | 2025-05-29 |

- 의미는 생겼지만, **통찰(Insight)** 은 없음.
→ “가장 인기 있는 상품” 같은 질문에는 아직 답 불가.

---

### 2. 정보(Information)
- **정의:** 구조화된 데이터를 **목적·질문**에 맞게 가공·분석하여 얻은 유의미한 결과물.
- **예:**
- 질문: “2025-05-30에 가장 많이 팔린 상품은?”
- 가공 과정:
1. 날짜 필터링 → 2025-05-30 주문만 추출
2. 상품별 그룹화 + 수량 합계
- 결과: `티셔츠` 4개로 1위

- **특징:**
- 데이터 → 의미 + 맥락 + 통찰
- 의사결정에 직접 활용 가능

---

### 왜 중요한가?
- **정보**를 알아야 → 재고 관리, 마케팅, 매출 분석 등 **효율적 의사결정** 가능
- 데이터베이스는 이 과정(구조화 → 가공 → 정보 생성)을 지원하는 핵심 도구

### 데이터베이스 정리

- 데이터베이스의 궁극적인 목적은 `데이터(의미 없는 기록 조각)`를 수집하고, 이를 가공 및 구조화해서 `정보(의미와 통찰을 담은 결과물)`을 만들어 `의사결정`에 활용하는 것 이라고 정리할 수 있다.

## 데이터베이스 관리 시스템이 필요한 이유

### 1. 데이터 저장 필요성
- 고객 정보, 상품 정보, 주문 내역 등 데이터를 **저장**해야만 정보로 가공 가능
- 소규모일 땐 메모장, 종이 장부, 엑셀로 가능하지만
규모가 커지면 비효율·오류 발생

---

### 2. 파일 시스템 한계
#### (1) 데이터 중복과 불일치
- 동일한 데이터가 여러 파일에 중복 저장 → 수정 시 불일치 발생
- 예: 고객 주소를 한 파일만 수정하면 다른 파일과 값이 달라짐

#### (2) 데이터 접근 어려움
- 여러 파일에 흩어진 데이터를 조건별로 조회·결합하기 힘듦
- 새로운 검색 조건이 생길 때마다 비효율적인 수작업/코드 작성 필요

#### (3) 데이터 무결성 제약 불가
- 가격이 음수이거나 수량이 0인 잘못된 데이터도 저장 가능
- 중복 ID 방지 같은 규칙을 강제하기 어려움

#### (4) 동시성 제어 문제
- 여러 사용자가 동시에 수정 시 데이터 꼬임 발생
- 예: 재고 1개 남았는데 2명이 동시에 주문 처리

#### (5) 보안 한계
- 파일 전체 단위로만 접근 권한 부여 가능
- 민감 정보(계좌, 주민번호 등) 일부만 제한하는 건 어려움

#### (6) 백업·복구 어려움
- 장애 발생 시 최신 상태로, 데이터 일관성을 유지하며 복구하기 어려움

---

### 3. DBMS의 필요성
- 데이터 중복 최소화 및 일관성 유지
- 다양한 조건 검색·활용 가능
- 무결성 규칙 강제
- 동시성 제어 제공
- 세밀한 보안 정책 적용 가능
- 백업·복구 체계 지원

## DBMS(Database Management System)의 정의

### 1. DBMS란?

- **정의**: 데이터베이스를 **생성, 관리, 조작**하는 소프트웨어 시스템
- 사용자와 데이터베이스 사이에서 **중간 관리자** 역할
- 데이터에 대한 모든 요청을 처리하고 응답하는 시스템

---

### 2. 파일 시스템과 DBMS 차이점

#### 파일 시스템

- 데이터를 개별 파일로 저장 관리
- 응용 프로그램이 직접 파일을 읽고 씀
- 데이터 처리 로직이 각 프로그램에 분산

#### DBMS

- 데이터를 **통합된 저장소**에서 관리
- 모든 데이터 접근이 **DBMS를 통해서만** 이루어짐
- 데이터 처리 로직이 DBMS에 집중화

---

### 3. DBMS의 핵심 기능

#### (1) 데이터 정의어(DDL - Data Definition Language)

- 데이터베이스 **구조를 정의**
- 테이블 생성·수정·삭제, 제약조건 설정
- 예: 고객 테이블 생성, 고객ID를 기본키로 설정

#### (2) 데이터 조작어(DML - Data Manipulation Language)

- 데이터 **삽입(Insert)**, **조회(Select)**, **수정(Update)**, **삭제(Delete)**
- **SQL(Structured Query Language)** 사용
- 예: "Top 5 고객 조회", "특정 고객 주문 내역 수정"

#### (3) 보안, 동시성 제어, 트랜잭션 관리

- **보안**: 사용자별 접근 권한 관리
- **동시성 제어**: 잠금(Locking) 메커니즘으로 동시 접근 제어
- **트랜잭션 관리**: ACID 속성 보장 (원자성, 일관성, 고립성, 지속성)
- 예: 계좌이체 시 (1)출금, (2)입금이 모두 성공하거나 모두 실패

#### (4) 데이터 무결성 보장

- **정규화(Normalization)**: 데이터 중복 최소화
- **제약조건**: 잘못된 데이터 입력 방지
- 예: 고객 테이블에서 고객ID 중복 방지, 주문 테이블에서 존재하지 않는 고객ID 참조 방지

#### (5) 데이터 백업 및 복구

- 정기적인 **백업** 수행
- 시스템 장애 시 **일관성 있는 복구** 지원
- 로그(Log) 기능으로 변경 사항 추적

---

### 4. DBMS 사용의 장점

- **데이터 중복 최소화** 및 일관성 유지
- **표준화된 접근 방법**(SQL) 제공
- **다중 사용자 환경** 지원
- **데이터 보안** 및 권한 관리
- **장애 복구** 체계 완비
- **데이터 무결성** 자동 보장

---

### 5. 데이터베이스 vs DBMS

- **데이터베이스(DB)**: 실제 데이터가 저장된 저장소
- **DBMS**: 데이터베이스를 관리하는 소프트웨어 도구
- 관계: DBMS가 DB를 생성·관리하며, 사용자는 DBMS를 통해 DB에 접근

## 관계형 데이터베이스(RDBMS) vs NoSQL

### 1. 관계형 데이터베이스(RDBMS)

#### 기본 개념

- **구조**: **테이블(Table)** 기반으로 데이터 저장
- **관계**: 행(Row,레코드,튜플)과 열(Column,필드,속성)로 구성된 2차원 표 형태
- **스키마**: 사전에 정의된 **엄격한 구조** 필요

#### 예시: 고객-주문 관계

**고객(customers) 테이블**

|customer_id (PK)|first_name|last_name|email|phone_number|
|---|---|---|---|---|
|1|John|Doe|[john.doe@email.com](mailto:john.doe@email.com)|010-1234-5678|
|2|Jane|Smith|[jane.smith@email.com](mailto:jane.smith@email.com)|010-1234-0001|

**주문(orders) 테이블**

|order_id (PK)|customer_id (FK)|order_date|total_amount|
|---|---|---|---|
|101|1|2025-03-15|55,000|
|102|2|2025-03-17|120,000|

- `customer_id`가 **외래키(FK)**로 두 테이블을 연결
- 관계를 통해 "누가 언제 무엇을 주문했는지" 파악 가능

#### RDBMS의 특징

- **ACID 속성**: 원자성, 일관성, 고립성, 지속성 보장
- **SQL 표준**: 구조화된 질의 언어 사용
- **데이터 정규화**: 중복 최소화로 일관성 유지
- **관계 무결성**: 외래키를 통한 데이터 일관성 보장

#### RDBMS의 한계점

- **수직적 확장**만 가능 (서버 성능 업그레이드)
- **고정된 스키마** 구조로 인한 유연성 부족
- **대용량 데이터** 처리 시 성능 저하
- **복잡한 관계**가 없는 단순 데이터에도 무거운 구조

---

### 2. NoSQL 데이터베이스

#### 기본 개념

- **정의**: "Not Only SQL"의 줄임말
- **특징**: RDBMS의 한계를 극복하기 위해 등장
- **유연성**: **스키마가 자유롭거나 없음**

#### NoSQL이 등장한 배경

- **빅데이터 시대**: 대용량 데이터 처리 요구 증가
- **웹 서비스 확장**: 수평적 확장(Scale-out) 필요성
- **다양한 데이터**: 비정형 데이터(이미지, 동영상, 로그) 저장 요구
- **빠른 개발**: 스키마 변경의 유연성 필요

#### NoSQL의 4가지 유형

**(1) Key-Value 저장소**

- **구조**: 키-값 쌍으로 단순하게 데이터 저장
- **특징**: 가장 빠른 성능, Redis는 메모리 기반
- **예시**: Redis, Memcached
- **용도**: 캐싱, 세션 관리, 실시간 순위

**(2) Document 데이터베이스**

- **구조**: JSON/BSON 형태의 문서로 데이터 저장
- **특징**: 중첩된 구조 표현 가능, 스키마 유연
- **예시**: MongoDB, Couchbase
- **용도**: 웹 애플리케이션, 콘텐츠 관리, API 개발

**(3) Column-family (열 지향)**

- **구조**: 열(Column) 단위로 데이터 저장 및 압축
- **특징**: 대용량 데이터 분석에 최적화
- **예시**: Cassandra, HBase
- **용도**: 빅데이터 분석, 시계열 데이터, 로그 분석

**(4) Graph 데이터베이스**

- **구조**: 노드(Node)와 엣지(Edge)로 관계 표현
- **특징**: 복잡한 관계 분석과 탐색에 특화
- **예시**: Neo4j
- **용도**: 소셜 네트워크, 추천 시스템, 지식 그래프

---

### 3. RDBMS vs NoSQL 상세 비교

|구분|RDBMS|NoSQL|
|---|---|---|
|**데이터 모델**|테이블(행/열)|Key-Value, Document, Column, Graph|
|**스키마**|고정 스키마 (사전 정의)|동적 스키마 (유연함)|
|**확장 방식**|수직 확장 (Scale-up)|수평 확장 (Scale-out)|
|**ACID 지원**|완전 지원|부분 지원 (Eventually Consistent)|
|**쿼리 언어**|표준 SQL|제품별 고유 API|
|**데이터 일관성**|강한 일관성|최종 일관성|
|**복잡한 관계**|뛰어남 (JOIN)|제한적|
|**성능**|복잡한 쿼리 우수|단순한 읽기/쓰기 우수|
|**학습 곡선**|SQL 표준으로 쉬움|제품마다 다름|

---

### 4. 언제 무엇을 선택할까?

#### RDBMS를 선택하는 경우

- **복잡한 관계**와 **JOIN**이 빈번한 데이터
- **데이터 일관성**이 매우 중요한 시스템 (금융, 회계)
- **ACID 트랜잭션**이 반드시 필요한 경우
- **표준 SQL** 사용으로 개발자 확보가 쉬운 경우
- **데이터 구조**가 안정적이고 변경이 적은 경우

#### NoSQL을 선택하는 경우

- **대용량 데이터** 처리가 주요 요구사항
- **빠른 읽기/쓰기** 성능이 중요한 경우
- **스키마 변경**이 자주 발생하는 애자일 개발
- **수평적 확장**(서버 추가)이 필요한 경우
- **비정형 데이터** 저장이 많은 경우

---

### 5. 주요 RDBMS vs NoSQL 제품군

#### RDBMS 제품

- **MySQL** (오픈소스): 가장 인기, 웹 개발 표준
- **MariaDB** (오픈소스): MySQL 포크, 향상된 기능
- **PostgreSQL** (오픈소스): 고급 기능, 확장성
- **Oracle** (상용): 엔터프라이즈급, 고성능
- **Microsoft SQL Server** (상용): .NET 생태계

#### NoSQL 제품별 특징

- **Redis**: 메모리 기반, 초고속 성능
- **MongoDB**: 문서형, 개발 편의성
- **Cassandra**: 분산형, 고가용성
- **Neo4j**: 그래프형, 관계 분석

---

### 6. 실무 선택 가이드

#### 프로젝트 초기 단계

- **요구사항이 명확하지 않다면**: **MySQL** 선택 (안정적, 범용적)
- **빠른 프로토타이핑이 필요하다면**: **MongoDB** 고려

#### 시스템 성격별 선택

- **전자상거래, 금융**: RDBMS (데이터 일관성 중요)
- **SNS, 게임**: NoSQL (대용량, 빠른 응답)
- **분석 시스템**: Column-family NoSQL (Cassandra)
- **추천 엔진**: Graph DB (Neo4j)

#### 현실적 고려사항

- **팀 역량**: 기존 개발팀이 SQL에 익숙한가?
- **운영 비용**: NoSQL은 학습비용과 운영복잡도 높음
- **하이브리드**: 필요에 따라 RDBMS + NoSQL 혼합 사용도 가능

---

### 7. 결론

- **완벽한 정답은 없다** - 프로젝트 특성에 따라 선택
- **RDBMS는 여전히 강력하다** - 대부분의 일반적인 애플리케이션에 적합
- **NoSQL은 특수 목적용** - 특정 요구사항에 최적화된 선택
- **미래 지향적 설계** - 확장 가능성을 고려한 아키텍처 설계 중요

# 관계형 데이터베이스 종류

## **Oracle (오라클 데이터베이스)**

- 매우 강력하고, 기능이 정말 많고, 안정성도 최고 수준인 상용 RDBMS의 대표 주자

- 주로 대기업이나 금융권처럼 아주 높은 수준의 성능과 안정성, 그리고 복잡한 기능을 필요로 하는 곳에서 많이 사용

- **단점**: 라이선스 비용이 매우 비싸고, 기능이 많은 만큼 배우고 관리하는 데 더 많은 전문성이 요구됨


## **MySQL (마이에스큐엘)**

- 전 세계적으로 **가장 널리 사용되는 오픈 소스 RDBMS** 중 하나

- 특히 웹 애플리케이션 개발 분야에서 압도적인 점유율을 자랑

- 빠른 속도와 사용 편의성, 그리고 방대한 커뮤니티와 자료 덕분에 초보자부터 전문가까지 폭넓게 사용

- MySQL 커뮤니티 에디션은 **무료**로 다운로드해서 사용 가능 (상용 버전은 유료)

- 배우기 쉽고 사용이 간편하며, 다양한 운영체제에서 잘 작동

- 풍부한 문서와 커뮤니티 지원을 받을 수 있으며, 특히 중소규모 서비스나 스타트업에서 비용 효율적으로 데이터베이스를 구축하고 운영하기에 적합

- **단점**: 복잡한 분석 쿼리나 대규모 트랜잭션 처리 성능은 상용 RDBMS나 PostgreSQL에 비해 다소 부족하다는 평가도 있었으나, 지속적인 성능 개선과 새로운 기능 추가로 많은 부분에서 격차를 줄여나가고 있음


## **PostgreSQL (포스트그레스큐엘, 줄여서 포스트그레스)**

- MySQL과 마찬가지로 매우 훌륭한 오픈 소스 RDBMS

- 기능적으로는 MySQL보다 더 뛰어나다고 평가받는 부분이 많음 (예: 복잡한 쿼리 처리 능력, 표준 SQL 준수, 확장 기능 등)

- 최근 몇 년간 인기가 급상승하며 많은 곳에서 사용되고 있음

- **단점**: 아직까지 국내 사용자가 많지 않음 (점점 늘어가는 추세)


## **Microsoft SQL Server (MS SQL)**

- 마이크로소프트에서 만든 RDBMS

- 특히 윈도우 서버 환경이나 닷넷(.NET) 기반 애플리케이션과 궁합이 좋음

- 강력한 성능과 다양한 도구를 제공

- **단점**: 주로 마이크로소프트 기술 스택을 사용하는 환경에서 선택되며, 오픈 소스 진영과는 약간 거리가 있음


## **MariaDB (마리아DB)**

- MySQL의 "쌍둥이 동생"이라고 생각하면 됨

- MySQL이 오라클에 인수된 후, MySQL의 창립 멤버들이 "오픈 소스 정신을 계속 이어가겠다"며 만든 MySQL 기반의 RDBMS

- MySQL과 거의 대부분 호환되기 때문에 MySQL 대신 MariaDB를 사용해도 대부분 문제가 없음

- MySQL을 배운다는 것은 MariaDB를 이해하는 것과 거의 같다고 봐도 무방


## **H2 Database (또는 SQLite)**

- 주로 **임베디드(내장형) 데이터베이스**로 사용됨

- 별도의 서버를 띄우는 것이 아니라 애플리케이션 자체에 포함되어 실행되는 가벼운 데이터베이스

- 주로 개발 단계에서의 빠른 테스트, 모바일 앱 내부 데이터 저장, 소규모 데스크톱 애플리케이션 등에 적용
## MySQL 소개

MySQL은 스웨덴의 한 회사(MySQL AB)에서 처음 개발되었고, 이후 썬 마이크로시스템즈(Sun Microsystems)를 거쳐 현재는 오라클(Oracle) 회사에 인수되어 관리되고 있음. 하지만 여전히 오픈 소스 라이선스를 따르기 때문에 많은 사용자들이 부담 없이 접근할 수 있음.

MySQL은 처음부터 **빠른 속도, 높은 안정성, 그리고 사용 편의성**을 목표로 설계되었으며, 특히 웹 애플리케이션과의 궁합이 좋아서 수많은 웹사이트와 온라인 서비스의 백엔드 데이터베이스로 사랑받아 왔음.

## RDBMS의 호환성과 ANSI SQL 표준

대부분의 RDBMS는 **ANSI/ISO에서 지정한 SQL 표준**을 준수하려고 노력함. Oracle, MySQL, MS SQL, PostgreSQL 등 대부분의 RDBMS는 이 표준을 따르기 때문에 데이터를 다루는 가장 핵심적인 부분인 조회(SELECT), 추가(INSERT), 수정(UPDATE), 삭제(DELETE) 등의 기본 문법은 거의 모든 RDBMS에서 비슷하게 사용할 수 있음.

결론적으로, MySQL을 통해 RDBMS의 핵심 개념과 표준 SQL을 제대로 배우면, 다른 종류의 데이터베이스(Oracle, PostgreSQL 등)를 접하더라도 쉽게 적응하고 사용할 수 있음.

## 실무에서의 DB 선택

실무에서 현실적으로 가능한 선택지는 주로 **오라클**이나 **MySQL(MariaDB 포함)** 두 가지임:

## 인력 수급의 현실

- 오라클과 MySQL은 국내에서 관련 인력을 구하기가 상대적으로 쉬움

- 다른 RDBMS 전문가는 찾기 어려워서 현실적인 선택에서 제외되는 경우가 많음

## 비용과 규모에 따른 선택

- **대기업/금융권/공공기관**: 오라클을 선택하는 경우가 많음 (높은 라이선스 비용을 감당할 수 있고, 미션 크리티컬한 시스템에서 요구되는 고급 기능과 기술 지원이 필요)

- **중소기업/스타트업/웹서비스**: MySQL을 선택하는 경우가 압도적으로 많음 (무료로 사용 가능, 웹 애플리케이션 개발에 최적화)

# 관계형 데이터베이스 핵심 개념

## 관계형 모델의 핵심 개념: 모든 데이터는 '표'에서 시작

관계형 데이터베이스는 데이터를 '표'의 형태로 관리함. 이것은 우리가 이미 엑셀을 통해 익숙하게 봐왔던 구조와 비슷함.

## 기본 구성 요소

**테이블(Table)**

- 관계형 데이터베이스에서 데이터를 저장하는 가장 기본적인 구조

- 엑셀의 '시트(Sheet)'와 거의 동일한 개념

- 특정 주제와 관련된 데이터들의 집합 (예: `고객 테이블`, `상품 테이블`, `주문 테이블`)


**행(Row)**

- 테이블의 각 가로줄을 의미

- 하나의 행은 개별적인 데이터 항목 하나를 나타냄

- 예: `고객 테이블`에서 하나의 행은 고객 한 명의 정보를 의미

- **실무 용어**: 레코드(Record) 또는 튜플(Tuple)이라고도 불림


**열(Column)**

- 테이블의 각 세로줄을 의미

- 열은 테이블에 어떤 종류의 데이터가 저장될지를 정의

- 예: `고객 테이블`의 `고객번호`, `이름`, `연락처`, `주소` 등

- **실무 용어**: 속성(Attribute) 또는 필드(Field)라고도 함


## 핵심 개념 1: 기본 키(Primary Key) - 수많은 데이터 속에서 '단 하나'를 식별하는 방법

## 문제 상황

쇼핑몰 운영 중 이름, 주소, 주문 상품이 완전히 똑같은 주문이 두 건 들어온 경우, 어떤 주문을 구분할 수 있는 방법이 필요함.

## 해결: 기본 키(Primary Key)

**기본 키란**, 테이블에 있는 모든 행들 중에서 특정 행 하나를 유일하게 식별할 수 있는 열 또는 열들의 조합

## 기본 키의 규칙

1. **고유성(Uniqueness)**: 기본 키로 지정된 열의 값은 같은 테이블 내에서 절대 중복될 수 없음

2. **NOT NULL**: 기본 키로 지정된 열에는 반드시 값이 있어야 함. 비어있거나(NULL) 값이 없는 상태는 허용되지 않음

## 왜 기본 키가 필수적인가?

- 수많은 데이터 속에서 특정 데이터 하나를 빠르고 정확하게 찾아내고, 수정하고, 삭제하기 위해

- 기본 키가 없다면 데이터의 바다에서 원하는 정보를 특정할 수 없음

- **모든 테이블에는 기본 키를 설정하는 것이 원칙**


## 실무 팁

- 보통 `id`라는 이름의 열을 만들고, 1부터 시작하여 데이터가 추가될 때마다 1씩 자동으로 증가하는 정수값을 기본 키로 사용

- `customer_id`, `product_id`와 같이 `테이블명_id` 형식으로 이름을 짓는 것이 일반적인 관례


## 핵심 개념 2: 외래 키(Foreign Key) - 따로 떨어진 표들을 '관계'로 묶는 방법

## 문제 상황

데이터 중복을 피하기 위해 정보를 '고객'과 '주문'이라는 두 개의 테이블로 나누어 저장했을 때, 어떤 주문이 어떤 고객에 의해 이루어졌는지 연결할 방법이 필요함.

## 해결: 외래 키(Foreign Key)

**외래 키란**, 한 테이블(A)의 열이 다른 테이블(B)의 기본 키 값을 참조하는 것

## 부모와 자식의 관계

- **자식 테이블**: FK 값을 통해 부모 테이블을 참조함. FK 값을 가진 곳이 자식 테이블

- **부모 테이블**: 참조당하는 테이블

- 예: `orders` 테이블이 `customer_id`를 통해 `customers` 테이블을 참조하는 경우

- `orders`가 자식 테이블

- `customers`가 부모 테이블

## 외래 키의 중요한 규칙

**참조 무결성(Referential Integrity)**

- 외래 키 열에 있는 값은 반드시 부모 테이블의 기본 키 값 중 하나이거나, 비어있어야(NULL) 함

- 존재하지 않는 값을 넣으려고 하면 데이터베이스가 오류를 발생시켜 막아줌

- 이를 통해 데이터의 정합성이 보장됨


## 왜 외래 키를 사용하는가?

- 데이터의 중복을 막음

- 데이터의 일관성을 유지

- 논리적으로 분리된 데이터들 사이에 '관계'를 맺어줌

- 작고 관리하기 쉬운 여러 개의 테이블로 전체 시스템을 구조화할 수 있음


## 정리

관계형 데이터베이스의 가장 핵심적인 개념 세 가지:

1. **테이블(Table)**: 데이터를 저장하는 표 형태의 기본 구조

2. **기본 키(Primary Key)**: 테이블의 모든 행을 유일하게 식별하는 값

3. **외래 키(Foreign Key)**: 테이블 간의 관계를 맺어주는 연결고리


- 이 개념들을 통해 데이터의 중복을 방지하고, 데이터 불일치 문제를 해결하며, 논리적으로 분리된 데이터를 연결하여 관리할 수 있음.


## 데이터베이스 정리

### 1. 데이터와 정보

- **데이터**: 가공되지 않은 개별적인 사실이나 값 (예: "user01", "티셔츠", "25,000").

- **구조화된 데이터**: 의미를 부여하기 위해 레이블이 붙은 데이터 (예: 표 형태로 정리된 주문 데이터).

- **정보**: 구조화된 데이터를 특정 목적에 맞게 분석·가공한 유의미한 결과물 (예: "5월 30일 가장 많이 팔린 상품은 티셔츠, 총 4개").

### 2. 데이터베이스 관리 시스템(DBMS)의 필요성

파일 시스템(텍스트/엑셀)의 한계:

- **데이터 중복 및 불일치**: 동일 정보가 여러 파일에 중복 저장되어 수정 시 일관성 유지 어려움.

- **데이터 접근 어려움**: 여러 파일에 흩어진 데이터를 조합해 정보 추출이 복잡함.

- **무결성 제약 어려움**: 가격 ≥ 0, 수량 ≥ 1 같은 규칙 강제 불가.

- **동시성 제어 문제**: 다중 사용자 접근 시 데이터 일관성 유지 어려움 (예: 재고 관리 오류).

- **보안 문제**: 세분화된 접근 권한 제어 불가.

- **백업/복구 어려움**: 장애 발생 시 데이터 복원이 복잡함.

### 3. DBMS란?

- **역할**: 사용자와 데이터베이스 사이에서 데이터 생성, 조회, 수정, 삭제를 관리하는 소프트웨어.

- **핵심 기능**:

- **DDL (Data Definition Language)**: 데이터 구조/제약조건 정의 (테이블 생성, 열 타입 설정 등).

- **DML (Data Manipulation Language)**: 데이터 조작 (INSERT, SELECT, UPDATE, DELETE).

- **트랜잭션 관리**: ACID(원자성, 일관성, 고립성, 지속성) 보장 (예: 계좌 이체 작업의 안전성).

- **보안/동시성 제어**: 사용자 권한 관리, 다중 접근 제어.

- **데이터 중복 최소화**: 정규화를 통한 효율적 저장.

- **백업/복구**: 로그 기반 복구 지원.

### 4. 관계형 DB(RDBMS) vs NoSQL

- **RDBMS** (MySQL, Oracle):

- **특징**: 테이블 간 관계 기반, SQL 사용, ACID 트랜잭션 지원.

- **적합한 경우**: 구조화된 데이터, 높은 일관성 요구 (예: 금융 시스템).

- **NoSQL** (Redis, MongoDB):

- **특징**: 유연한 스키마, 수평 확장 용이, 다양한 데이터 모델(키-값, 문서 등).

- **적합한 경우**: 대량 비정형 데이터, 실시간 처리 (예: SNS 피드).

### 5. RDBMS 핵심 개념

- **테이블(Table)**: 행과 열로 구성된 데이터 저장 단위.

- **행(Row/Record)**: 개별 데이터 항목 (예: 고객 1명의 정보).

- **열(Column/Field)**: 데이터 속성 정의 (예: `고객ID`, `이름`).

- **기본 키(Primary Key, PK)**:

- 테이블에서 행을 **유일하게 식별**하는 열.

- **규칙**: 고유성(중복 불가), NOT NULL.

- 예: `order_id` (주문 테이블).

- **외래 키(Foreign Key, FK)**:

- 다른 테이블의 PK를 **참조**하는 열.

- **참조 무결성**: FK 값은 반드시 참조된 테이블의 PK 값이어야 함.

- 예: `orders.customer_id` → `customers.customer_id`.

### 6. 주요 RDBMS 종류

- **MySQL**: 오픈 소스, 웹 애플리케이션에 적합, 학습 용이.

- **Oracle**: 대기업용, 고성능/고가.

- **PostgreSQL**: 오픈 소스, 복잡한 쿼리/확장성 우수.

- **SQL Server**: 마이크로소프트 생태계 통합.

### 7. 실무 팁

- **DB 선택 기준**:

- 중소기업/스타트업 → **MySQL** (비용 효율성).

- 대기업/금융 → **Oracle** (고급 기능 요구).

- **학습 우선순위**: RDBMS(특히 MySQL) 먼저 마스터 → 필요 시 NoSQL 추가 학습.

### 8. 요약: DBMS의 가치

- 데이터를 **체계적으로 저장** → 중복/불일치 해결.

- **효율적인 정보 추출** → 의사결정 지원.

- **안정성/보안** 보장 → 비즈니스 핵심 인프라 역할.