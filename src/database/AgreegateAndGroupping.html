<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title># 집계와 그룹핑

      ## COUNT

      - `COUNT(*)` : 모든 행(row)의 개수를 센다. `NULL` 포함

      - `COUNT(컬럼명)` : 특정 컬럼의 값 중 `NULL`이 아닌 행만 센다

      ```sql
      SELECT  COUNT(*) AS 전체주문건수, COUNT(category) AS 카테고리등록건수 FROM order_stat;
      ```

      - `COUNT(*)`는 테이블의 모든 행을 센다.
      - `COUNT(category)`는 `NULL`을 제외하고 세기 때문에 누락된 데이터가 있을 경우 개수가 줄어든다.

      ---
      ## SUM / AVG

      - `SUM(컬럼명)` : 합계 계산

      - `AVG(컬럼명)` : 평균 계산

      ```sql
      SELECT SUM(price * quantity) AS 총매출액,     AVG(price * quantity) AS 평균주문금액 FROM order_stat;
      ```

      - 매출액을 계산할 때는 단가와 수량을 곱한 값을 합산한다.
      - 평균 주문 금액은 주문 건당 평균 구매액(객단가)을 의미한다.

      ---
      ## MAX / MIN

      - `MAX(컬럼명)` : 최댓값 반환

      - `MIN(컬럼명)` : 최솟값 반환

      ```sql
      SELECT  SUM(price * quantity) AS 총매출액, AVG(price * quantity) AS 평균주문금액 FROM order_stat;
      ```

      - 상품 단가의 최대·최소값을 확인하면 가격대 분포를 쉽게 파악할 수 있다.
      - 날짜 컬럼에 적용하면 가장 오래된 날짜와 가장 최근 날짜를 확인할 수 있다.

      ---
      ## DISTINCT

      - 중복 제거 후 고유한 값만 집계할 때 사용

      ```sql
      `SELECT COUNT(customer_name) AS 총주문건수, COUNT(DISTINCT customer_name) AS 순수고객수 FROM order_stat;`
      ```

      - 중복된 고객 이름을 포함하면 총 주문 건수가 되고,
      - 중복을 제거하면 실제로 구매한 고유 고객 수를 알 수 있다.

      ---

      ## GROUP BY

      - 특정 컬럼 값을 기준으로 그룹을 묶은 뒤 집계

      ```sql
      SELECT  category, COUNT(*) AS 카테고리별주문건수 FROM order_stat GROUP BY category;
      ```

      - `GROUP BY`는 같은 값을 가진 행들을 하나의 그룹으로 묶는다.
      집계 함수와 함께 사용하면 그룹별 통계를 낼 수 있다.
      - `NULL` 값도 하나의 그룹으로 처리된다.

      ---

      ### GROUP BY와 집계 함수 결합

      ```sql
      SELECT customer_name, COUNT(*) AS 총주문횟수, SUM(quantity) AS 총구매수량,     SUM(price * quantity) AS 총구매금액 FROM order_stat GROUP BY customer_name ORDER BY 총구매금액 DESC;
      ```

      - 고객별로 주문 횟수, 수량, 총 구매 금액을 계산하고, 구매 금액 순으로 정렬할 수 있다.

      ---

      ## GROUP BY 주의사항

      - `SELECT` 절에는 **GROUP BY에 사용된 컬럼** 또는 **집계 함수**만 올 수 있다.

      - 그룹화된 상태에서 개별 행의 값을 단독으로 조회할 수 없다.

      ---

      ## 여러 컬럼으로 그룹화

      ```sql
      SELECT customer_name, category, SUM(price * quantity) AS 카테고리별구매금액 FROM order_stat GROUP BY customer_name, category ORDER BY customer_name, 카테고리별구매금액 DESC;
      ```

      - 여러 기준을 동시에 지정하면 고객별 + 카테고리별로 세분화된 그룹을 만들 수 있다.

      ---
      ## HAVING

      - 그룹화된 결과에 조건을 걸 때 사용

      ```sql
      SELECT category, SUM(price * quantity) AS total_sales FROM order_stat GROUP BY category HAVING SUM(price * quantity) >= 500000;
      ```

      - `WHERE`는 그룹화 이전의 개별 행을 필터링한다.
      - `HAVING`은 그룹화 이후의 결과에 조건을 적용한다.

      ---
      ### WHERE와 HAVING 함께 사용

      ```sql
      SELECT category, COUNT(*) AS premium_order_count FROM order_stat WHERE price >= 100000 GROUP BY category HAVING COUNT(*) >= 2;
      ```

      - `WHERE` : 먼저 가격이 10만 원 이상인 행만 남긴다.

      - `GROUP BY` : 카테고리별로 묶는다.

      - `HAVING` : 그룹별 주문 건수가 2건 이상인 카테고리만 필터링한다.

      ---
      ### ORDER BY 주의사항

      ```sql
      select
      customer_name, count(*) as `총 주문 횟수`,
      sum(quantity) as `총 구매 수량`,
      sum(price*quantity) as `총 구매 금액`
      from
      order_stat
      group by customer_name
      order by `총 구매 금액` desc
      ```

      - `order by`에서 `백틱` 기호가 아닌 `'(작은 따옴표)`를 사용하면 문자열로 인식되기에 정렬을 할 수 없으니 `백틱` 기호를 사용하여 정렬하거나 혹은 `sum(price*quantity)`같은 집계 함수를 그대로 넣어서 정렬해야 한다.
      ---
      ## SQL 실행 순서

      SQL 문법은 우리가 작성하는 순서와 실제 실행 순서가 다르다.

      **실행 순서**

      1. FROM
      2. WHERE
      3. GROUP BY
      4. HAVING
      5. SELECT
      6. ORDER BY
      7. LIMIT

      - `WHERE` 절에서는 `SELECT` 절에서 정의한 별칭을 사용할 수 없다.
      - 왜냐하면 `WHERE`가 실행되는 시점에는 `SELECT`가 아직 처리되지 않았기 때문이다.</title>
</head>
<body>

</body>
</html>