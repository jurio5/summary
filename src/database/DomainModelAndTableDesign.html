
1. 양방향 테이블 설계보단 단방향 테이블 설계가 옳다.
2. 외래키가 있는 곳을 연관관계의 주인으로 정해라
- 연관관계의 주인은 단순히 외래 키를 누가 관리하냐의 문제이지 비즈니스 상 우위에 있다고 주인으로 정하면 안 된다.
- 주인이 아닌 곳은 `mappedBy`를 통해 읽기 전용으로 조회 용도로만 사용
- 항상 `1:N` 관계에선 `N`이 연관관계의 주인이 된다.
3. 다대다(`ManyToMany`) 사용을 자제하라.
4. `ENUM` 타입을 사용 할 경우 `@Enumerated`를 `EnumType.STRING`으로 관리하라
- 기본이 `ORDINAL`방식 이기에 이 방식은 `pk`처럼 숫자로 관리가 되는데 이 상황에서 중간에 ENUM 타입이 더 추가가 될 경우 문제가 생길 수 있기에 `STRING`으로 관리
5. `OneToMany`,`ManyToMany` 를 제외한 연관 관계는 `LAZY`로 설정하는 것이 좋다.
- `OneToMany`,`ManyToMany` 의 기본 fetch 전략은 이미 `LAZY`라 별도로 설정 할 필요가 없다.
- 반면, `ManyToOne`,`OneToOne`의 기본 `fetch`전략은 `EAGER`이므로 명시적으로 `fetch = LAZY`를 설정하는 것이 좋다.
- `fetch`전략은 연관관계의 주인 쪽에 설정해야 적용된다.
6. `Cascade`관리는 주체가 되는 쪽에서 관리 하라
- `Member`와 `Order` 관계에선 `Member`가 사라지면 `Order`도 제거되어야 하기에 `Member`에서 관리하는 것 처럼
7. `OneToOne`관계에선 `pk`를 어디서 둬도 상관 없지만 최대한 엑세스가 많이 되는 곳에 두는게 좋다.
- `Order`와 `Delivery`의 연관 관계가 1:1 일 경우 보통 `Order`테이블이 엑세스 되는 경우가 더 많기에 `Order`에 두는 편이 좋음
8. 엔티티는 가급적 `Setter`를 사용하지 말자
9. 모든 연관관계는 지연로딩(`LAZY`)으로 설정
- JPA는 기본적으로 연관관계를 **즉시 로딩(`EAGER`)** 으로 설정하는데, 이 경우 연관된 엔티티들을 **모두 즉시 로딩**하기 때문에 **어떤 SQL이 실행되는지 예측하기 어렵고, 추적이 힘들다**.
- 기본적으로 연관관계를 즉시 로딩으로 설정하는 부분은 `5`번  참조
- 특히 `JPQL`을 사용할 때 `N + 1 문제`가 자주 발생한다.
- **지연 로딩(`LAZY`)** 에서도 `N + 1` 문제가 발생할 수 있지만, **필드가 실제로 접근될 때** 쿼리가 실행되므로, **개발자가 `fetch join` 등을 사용해 제어할 수 있는 여지가 있다**.
- 반면 **즉시 로딩(`EAGER`)** 은 단일 쿼리로 데이터를 조회할 때, **연관된 모든 엔티티가 즉시 함께 로딩**되므로 **불필요한 SQL 실행이 많아지고**, 성능 문제로 이어질 수 있다.
- 따라서 모든 연관관계는 기본적으로 `LAZY`로 설정하고, **정말 필요한 경우에만 `fetch join`이나 엔티티 그래프 등을 활용해 명시적으로 함께 조회**하는 방식이 바람직하다.
10. 컬렉션은 필드에서 바로 초기화를 하는게 베스트 프랙티스 이다.
- `List<Order> orders = new ArrayList<>();`
  11. 테이블, 컬럼명 생성 전략
  - 하이버네이트 기존 구현 : 엔티티의 필드명을 그대로 테이블로 사용
  - `소문자 변환` + `카멜 케이스` + `스네이크 케이스`
  - `orderItem` -> `order_item`