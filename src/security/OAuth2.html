1. OAuth2 인증 시작 시 Filter 구조 상 SecurityConfig 쪽의 OAuth2 Login Filter 가 제일 먼저 실행
- customOAuth2AuthorizationRequestRepository 에 OAuth2 인증 정보를 쿠키에 저장 (추후 인증 완료 후 상태를 검증할 때 사용)
- 여기서 OAuth2 쿠키는 만료 시간이 3분인데, 3분 동안 OAuth2 로그인 창에서 로그인을 하지 않을 시 토큰이 만료되어 다시 로그인을 해야 함
- 이 부분이 필요한 이유는 CSRF 공격 및 리소스 낭비 방지를 위함
- CSRF 공격은 사용자의 인증된 세션을 이용해서 악성 요청을 계속 보내는 방식
- .userService(customOAuth2UserService) 부분이 실행되며, 이 클래스로 이동

2. 프론트 쪽에서 사용자가 OAuth2 로그인 시 리소스 서버는 사용자에게 리다이렉트 주소에 인증 코드를 넣어서 리다이렉트
- 그 인증 코드를 사용자는 백엔드 서버 쪽으로 던져주며, 백엔드 서버는 그 인증 코드를 들고 리소스 서버와 직접 통신을 하여
인증 코드가 올바르다면, 백엔드 서버 쪽으로 사용자 정보가 담긴 엑세스 토큰을 발급
- 백엔드 서버에선 그 발급받은 엑세스 토큰을 들고 리소스 서버에 사용자의 정보를 요청

3. loadUser 메서드에 그 정보들이 저장이 되며, 그 제공받은 사용자의 정보를 processOAuth2User 메서드로 전달
- processOAuth2User 에서는 그 정보를 가공을 하고, 그 가공 된 정보를 SecurityUser 객체에 담아두고 다음 필터로 이동
- 여기서 isNewUser 는 oauth 테이블에 현재 이 사용자의 provider 와 oauthId 가 테이블에 있는지 없는지를 체크

4. 그 정보를 OAuth2LoginProvider가 사용자 정보 +제공자 정보 + 권한 등 여러가지 종합적인 내용들을 담아 토큰을 만든 뒤 SecurityContext에 저장

5. 이 과정에서 다음 필터로 이동 될 때 정보가 사용자의 정보와 제공자의 정보를 비교해서 올바른 정보라면 SuccessHandler 쪽으로,
올바르지 않다면 FailHandler 쪽으로 이동

6. 성공했다고 가정 시 SuccessHandler에서 Context에 저장해둔 정보를 토대로, 신규 유저와 기존 유저의 정보를 나눠서 프론트로 전달
- isNewUser 가 true 일 시 신규 회원으로, 상태를 "REGISTER" 로 설정 후 프론트로 전달
- isNewUser 가 false 일 시 기존 회원으로, 엑세스 토큰과 리프레쉬 토큰을 HttpOnly 방식으로 쿠키를 설정 및
역활을 Non-HttpOnly 방식으로 설정 후 프론트로 전달
